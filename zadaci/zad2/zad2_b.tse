version = 4.2

//
// Saved by sw version: 2024.1
//

model "zad2_b" {
    configuration {
        hil_device = "VHIL+"
        hil_configuration_id = 1
        simulation_method = exact
        simulation_time_step = 1e-6
        simulation_discret_scaling = 1.0
        dsp_timer_periods = 100e-6, 50e-3
        ss_calc_method = "systematic elimination"
        enb_pole_shift = True
        enb_gds_oversampling = True
        show_modes = False
        device_ao_limit_enable = False
        reset_analog_outputs_on_sim_stop = True
        reset_analog_outputs_on_sim_stop_mode = Offset values
        reset_digital_outputs_on_sim_stop = True
        vhil_adio_loopback = False
        cpl_stb = False
        enb_dep_sw_detect = False
        code_section = "internal memory"
        data_section = "internal memory"
        sys_sp_rate_1 = 0.0001
        sys_sp_rate_2 = 0.05
        sys_real_type_precision = "default"
        user_real_type_precision = "default"
        sys_cpu_optimization = "high"
        user_cpu_optimization = "high"
        user_cpu_part_option = "default"
        matrix_based_reduction = True
        cpl_dynamics_analysis = False
        export_ss_to_pickle = False
        ground_scope_core = False
        dss_num_tol = 1e-15
        cce_platform = "generic"
        cce_use_relative_names = False
        cce_type_mapping_real = "double"
        cce_type_mapping_uint = "unsigned int"
        cce_type_mapping_int = "int"
        cce_platform = "generic"
        cce_use_relative_names = False
        cce_type_mapping_real = "double"
        cce_type_mapping_uint = "unsigned int"
        cce_type_mapping_int = "int"
        cce_directory = ""
        cce_custom_type_int = ""
        cce_custom_type_uint = ""
        cce_custom_type_real = ""
        tunable_params = "component defined"
        sp_compiler_type = "C compiler"
        sig_stim = "off"
        export_resource_list = ""
        export_dependency_list = ""
        excluded_resource_list = ""
        export_out_file = ""
        export_lock_top_level = True
        export_encrypt_library = True
        export_encrypt_resources = True
        dae_solver = "BDF"
        max_sim_step = 1e-4
        simulation_time = 1.0
        abs_tol = 1e-3
        rel_tol = 1e-3
        init_sim_step = 1e-6
        r_on_sw = 1e-3
        v_on_diode = 0.2
        data_sampling_rate = 0
        feedthrough_validation_error_level = error
    }

    component Subsystem Root {
        component "core/Flyback" Flyback1 {
            L1 = "1e-9"
            L2 = "1e-9"
            Lm = "Lm"
            R1 = "Rp"
            R2 = "Rs"
            Rm = "1e6"
            carrier_freq = "fs"
            ctrl_src = "Internal modulator"
            d_time = "0"
            n1 = "1/n"
            ref_sig_min_max = "[0.0, 1.0]"
            signal_access = "Inherit"
        }
        [
            position = 8440, 8176
            size = 144, 256
        ]

        component "core/Voltage Source" Vin {
            init_const_value = "Vin"
        }
        [
            position = 7960, 8224
            rotation = right
        ]

        component "core/Capacitor" C_out {
            capacitance = "Cf"
            signal_access = "Inherit"
        }
        [
            position = 8656, 8128
            rotation = right
        ]

        component "core/Voltage Measurement" Vout {
            execution_rate = "Ts"
            sig_output = "True"
            signal_access = "Inherit"
        }
        [
            position = 8928, 8128
            rotation = right
            size = 64, 32
        ]

        component "core/Probe" "Duty ratio probe" {
        }
        [
            position = 9080, 7464
        ]

        component "core/SCADA Input" "Output power" {
            def_value = "7.5"
            max = "100"
            min = "7.5"
            signal_access = "Inherit"
            unit = ""
        }
        [
            position = 8392, 7840
        ]

        component "core/Gain" KReg {
            _tunable = "True"
            gain = "KReg"
        }
        [
            position = 8496, 7544
        ]

        component "core/Gain" 1_p {
            gain = "1/p"
        }
        [
            position = 8584, 7544
        ]

        component "core/Discrete Transfer Function" GLead {
            a_coeff = "GLeadDen"
            b_coeff = "GLeadNum"
            domain = "S-domain"
        }
        [
            position = 8672, 7544
        ]

        component "core/Sum" Sum1 {
            signs = "+-"
        }
        [
            position = 8392, 7544
            hide_name = True
        ]

        component "core/Constant" "Referent output voltage" {
            value = "Vout"
        }
        [
            position = 8208, 7504
        ]

        component "core/Limit" Limit1 {
            lower_limit = "0"
            upper_limit = "1"
        }
        [
            position = 8944, 7544
            hide_name = True
        ]

        component "core/Discrete Transfer Function" GLag {
            a_coeff = "GLag2Den"
            b_coeff = "GLag2Num"
            domain = "S-domain"
        }
        [
            position = 8760, 7544
        ]

        component "core/Variable Resistor" R_load {
            inductance = "1e-4"
        }
        [
            position = 8784, 8128
            rotation = right
            size = 64, 48
        ]

        component "core/Product" Product1 {
            signs = "*/"
        }
        [
            position = 8624, 7768
            hide_name = True
        ]

        component "core/Product" Product2 {
        }
        [
            position = 8392, 7760
            hide_name = True
        ]

        component "core/Rate Limiter" "Rate limiter" {
            falling_limit = "-10"
            rising_limit = "10"
        }
        [
            position = 8720, 7768
        ]

        component "core/Current Measurement" Iout {
        }
        [
            position = 8720, 8080
            size = 64, 32
        ]

        component "core/Voltage Source" Disturbance {
            init_frequency = "5"
            init_rms_value = "0.2 * 230"
            init_source_nature = "Sine"
        }
        [
            position = 7960, 8120
            rotation = right
        ]

        component "core/Sum" Sum2 {
        }
        [
            position = 8856, 7552
            hide_name = True
        ]

        component "core/Gain" KVinComp {
            gain = "KVinComp"
        }
        [
            position = 8680, 7648
        ]

        component "core/Voltage Measurement" IVM {
            execution_rate = "Ts"
            sig_output = "True"
            signal_access = "Inherit"
        }
        [
            position = 8200, 8176
            rotation = right
            size = 64, 32
        ]

        component "core/Sum" Sum3 {
            signs = "+-"
        }
        [
            position = 8560, 7648
            hide_name = True
        ]

        component "core/Constant" "Referent input voltage" {
            value = "Vin"
        }
        [
            position = 8416, 7624
        ]

        component "core/SCADA Input" Enable {
            def_value = "7.5"
            execution_rate = "Ts"
            max = "100"
            min = "7.5"
            signal_access = "Inherit"
            unit = ""
        }
        [
            position = 8216, 7984
        ]

        tag "Current output voltage" {
            value = "Voutcurr"
            scope = local
            kind = sp
            direction = out
        }
        [
            position = 8208, 7584
            size = 60, 20
        ]

        tag "Measured output voltage" {
            value = "Voutcurr"
            scope = local
            kind = sp
            direction = in
        }
        [
            position = 9024, 8128
            size = 60, 20
        ]

        tag Control {
            value = "u"
            scope = local
            kind = sp
            direction = in
        }
        [
            position = 9104, 7544
            size = 60, 20
        ]

        tag "Duty ratio" {
            value = "u"
            scope = local
            kind = sp
            direction = out
        }
        [
            position = 8296, 7904
            hide_name = True
            size = 60, 20
        ]

        tag Goto1 {
            value = "tag"
            scope = local
            kind = sp
            direction = in
        }
        [
            position = 8288, 8176
            hide_name = True
            size = 60, 20
        ]

        tag From1 {
            value = "tag"
            scope = local
            kind = sp
            direction = out
        }
        [
            position = 8416, 7688
            hide_name = True
            size = 60, 20
        ]

        junction Junction12 pe
        [
            position = 8656, 8176
        ]

        junction Junction15 pe
        [
            position = 8784, 8176
        ]

        junction Junction24 pe
        [
            position = 8784, 8080
        ]

        junction Junction25 pe
        [
            position = 8656, 8080
        ]

        junction Junction26 sp
        [
            position = 9008, 7544
        ]

        junction Junction30 pe
        [
            position = 8200, 8272
        ]

        junction Junction31 sp
        [
            position = 8312, 7504
        ]

        junction Junction32 sp
        [
            position = 8312, 7752
        ]

        junction Junction33 pe
        [
            position = 8200, 8080
        ]

        connect Junction12 Flyback1.b_out as Connection127
        [
            breakpoints = 8656, 8176; 8656, 8176
        ]
        connect C_out.n_node Junction12 as Connection128
        connect KReg.out 1_p.in as Connection158
        connect 1_p.out GLead.in as Connection159
        connect GLead.out GLag.in as Connection171
        connect Vout.n_node Junction15 as Connection186
        [
            breakpoints = 8808, 8176; 8792, 8176
        ]
        connect Junction15 Junction12 as Connection187
        [
            breakpoints = 8784, 8176; 8784, 8176; 8784, 8176; 8784, 8176; 8784, 8176
        ]
        connect R_load.n_node Junction15 as Connection188
        connect Product2.out Product1.in as Connection191
        connect Product1.out "Rate limiter.in" as Connection301
        connect "Output power.out" Product1.in1 as Connection302
        connect "Rate limiter.out" R_load.In as Connection303
        connect R_load.p_node Junction24 as Connection310
        connect Junction24 Vout.p_node as Connection311
        [
            breakpoints = 8784, 8080
        ]
        connect Iout.n_node Junction24 as Connection312
        connect Flyback1.a_out Junction25 as Connection313
        connect Junction25 C_out.p_node as Connection314
        [
            breakpoints = 8656, 8080; 8656, 8080; 8656, 8080
        ]
        connect Iout.p_node Junction25 as Connection315
        connect "Current output voltage" Sum1.in1 as Connection317
        [
            hide_name = True
        ]
        connect Vout.out "Measured output voltage" as Connection318
        connect Limit1.out Junction26 as Connection319
        connect Junction26 "Duty ratio probe.in" as Connection320
        [
            breakpoints = 9008, 7544; 9008, 7544; 9008, 7464
        ]
        connect Control Junction26 as Connection321
        connect "Duty ratio" Flyback1.In as Connection322
        connect GLag.out Sum2.in as Connection335
        connect Sum2.out Limit1.in as Connection336
        connect KReg.in Sum1.out as Connection338
        [
            breakpoints = 8448, 7544
        ]
        connect KVinComp.out Sum2.in1 as Connection339
        connect Vin.n_node Junction30 as Connection343
        connect Junction30 Flyback1.b_in as Connection344
        connect IVM.n_node Junction30 as Connection345
        connect IVM.out Goto1 as Connection346
        [
            breakpoints = 8248, 8176
        ]
        connect Sum3.out KVinComp.in as Connection347
        connect From1 Sum3.in1 as Connection348
        connect "Referent input voltage.out" Sum3.in as Connection349
        connect "Referent output voltage.out" Junction31 as Connection352
        connect Junction31 Sum1.in as Connection353
        [
            hide_name = True
            breakpoints = 8336, 7504
        ]
        connect Product2.in Junction32 as Connection355
        connect Junction32 Junction31 as Connection356
        connect Product2.in1 Junction32 as Connection357
        connect Vin.p_node Disturbance.n_node as Connection404
        [
            breakpoints = 7960, 8176
        ]
        connect Flyback1.a_in Junction33 as Connection405
        connect Junction33 IVM.p_node as Connection406
        [
            breakpoints = 8200, 8080; 8200, 8080; 8200, 8080; 8200, 8080
        ]
        connect Disturbance.p_node Junction33 as Connection407
        connect Enable.out Flyback1.En as Connection408
    }

    default {
        "core/Capacitor" {
            signal_access = "inherit"
            capacitance = "1e-6"
            initial_voltage = "0"
            pole_shift_ignore = "False"
            visible = "True"
        }

        "core/Constant" {
            value = "1"
            signal_type = "real"
            execution_rate = "100e-6"
            _tunable = "False"
        }

        "core/Discrete Transfer Function" {
            domain = "Z-domain"
            method = "Zero-order hold"
            b_coeff = "[1,1]"
            a_coeff = "[1,1]"
            signal_out_type = "inherit"
            execution_rate = "inherit"
        }

        "core/Gain" {
            gain = "1"
            multiplication = "Element-wise(K.*u)"
            _tunable = "False"
            execution_rate = "inherit"
        }

        "core/Limit" {
            upper_limit = "[\'inf\']"
            lower_limit = "[\'-inf\']"
            execution_rate = "inherit"
        }

        "core/Probe" {
            signal_access = "inherit"
            addr = "0"
            override_signal_name = "False"
            signal_name = ""
            signal_type = "generic"
            streaming_en = "False"
            streaming_er_idx = "0"
            execution_rate = "inherit"
        }

        "core/Product" {
            signs = "2"
            execution_rate = "inherit"
        }

        "core/Rate Limiter" {
            rising_limit = "1"
            rising_limit_source = "internal"
            falling_limit = "-1"
            falling_limit_source = "internal"
            execution_rate = "inherit"
        }

        "core/SCADA Input" {
            signal_access = "inherit"
            addr = "0"
            format = "real"
            override_signal_name = "False"
            signal_name = ""
            signal_type = "real"
            min = "-1e6"
            max = "1e6"
            def_value = "0"
            unit = " "
            execution_rate = "100e-6"
        }

        "core/Sum" {
            signs = "2"
            execution_rate = "inherit"
        }

        "core/Voltage Source" {
            sig_input = "False"
            type = "signal generator"
            param_set = "1phase"
            parent_label = ""
            addr = "0"
            spc_nb = "0"
            execution_rate = "100e-6"
            cpd_visible = "True"
            enable_snb = "False"
            snb_type = "R2"
            R2 = "0.0"
            L1 = "0.1"
            override_signal_name = "False"
            signal_name = ""
            init_source_nature = "Constant"
            init_const_value = "0.0"
            init_rms_value = "0.0"
            init_frequency = "50.0"
            init_phase = "0.0"
        }

        "core/Current Measurement" {
            signal_access = "inherit"
            bw_limit = "False"
            frequency = "10e3"
            comparator_enable = "False"
            operator = "greater"
            threshold = "0"
            cmp_abs_value = "False"
            feed_forward = "false"
            sig_output = "False"
            sig_output_filt_and_full_bw = "False"
            execution_rate = "100e-6"
            addr = "0"
            nd_msr_estimation = "false"
            dev_cpl_msr = "false"
            host_device = "0"
            output_to_device = "0"
            dev_cpl_index = "0"
            dev_cpl_var_nb = "0"
            visible = "True"
            override_signal_name = "False"
            signal_name = ""
        }

        "core/Flyback" {
            signal_access = "inherit"
            ctrl_src = "Digital inputs"
            op_mode = "Fixed carrier frequency"
            carrier_freq = "10000.0"
            carr_ph_offset = "0.0"
            d_time = "5e-6"
            ref_sig_min_max = "[-1.0, 1.0]"
            load_mode = "on min"
            execution_rate = "inherit"
            S1 = "1"
            S1_logic = "active high"
            show_monitoring = "False"
            n1 = "1"
            n2 = "1"
            L1 = "0.001"
            I1 = "0"
            L2 = "0.001"
            I2 = "0"
            Lm = "5"
            R1 = "0.1"
            R2 = "0.1"
            Rm = "1e4"
            pwm_enabling = "False"
            pwm_enable_di = "13"
            pwm_enable_inv = "active high"
        }

        "core/Variable Resistor" {
            inductance = "1e-3"
            initial_current = "0.0"
            hide_int_meas = "False"
        }

        "core/Voltage Measurement" {
            signal_access = "inherit"
            bw_limit = "False"
            frequency = "10e3"
            comparator_enable = "False"
            operator = "greater"
            threshold = "0"
            cmp_abs_value = "False"
            feed_forward = "false"
            sig_output = "False"
            sig_output_filt_and_full_bw = "False"
            execution_rate = "100e-6"
            addr = "0"
            nd_msr_estimation = "false"
            dev_cpl_msr = "false"
            host_device = "0"
            output_to_device = "0"
            dev_cpl_index = "0"
            dev_cpl_var_nb = "0"
            visible = "True"
            override_signal_name = "False"
            signal_name = ""
        }
    }

    CODE model_init
        # Numpy module is imported as 'np'
        # Scipy module is imported as 'sp'
        # The Schematic API is imported as 'mdl'
        # To get the model file path, use 'mdl.get_model_file_path()'
        # To print information to the console, use info()
        
        import control as ct
        
        # plant criteria
        Vin = 230 * np.sqrt(2)
        Vout = 20  # [V] Output voltage
        P_losses_max = 0.5  # [W] Maximum losses in worst scenario steady state
        n = 0.2
        fs = 2500  # [Hz]
        Vout_ripple_max = 0.03  # [p.u.] of nominal Vout
        Iout_ripple_max = 0.10  # [p.u.] of nominal Iout
        
        # control criteria
        critical_damping = True
        Pout_min = 7.5  # [W]
        Pout_min = 100  # [W]
        input_disturbance_1_Amp = 0.2  # [p.u.] of Nominal amplitude
        input_disturbance_1_F = 0.1  # [p.u.] of Nominal frequency
        input_disturbance_2_Amp = 0.2  # [p.u.] of Nominal amplitude
        input_disturbance_2_F = 10  # [p.u.] of Nominal frequency
        
        
        ########
        Ts = 100e-6
        Rp = 0.001
        Rs = 0.0001
        
        def getRlList():
            RlList = []
            for Pout in PoutList:
                RlList.append(Vout**2 / Pout)
            return RlList
            
        def getD0List(RlList):
            D0List = []
            for Rl in RlList:
                a = Rl * (n * Vin + Vout)
                b = (n**2 * Rp - Rs) * Vout - (n * Vin + 2 * Vout) * Rl
                c = (Rl + Rs) * Vout
                D0List.append(min(np.roots([a, b, c])))
            return D0List
            
        def getLmList(RlList, D0List):
            LmList = []
            for i in range(len(RlList)):
                D0 = D0List[i]
                Rl = RlList[i]
                a = (1 - D0) * ((1 - D0) * Rl + Rs)
                b = 2 * n**2 * fs
                LmList.append(a / b)
            return LmList
            
        def getCfList(RlList, D0List):
            CfList = []
            for i in range(len(RlList)):
                D0 = D0List[i]
                Rl = RlList[i]
                a = (1 - D0) * n * D0**2 * 1.2 * Vin
                b = 2 * k * fs * Vout * ((1 - D0)**2 * Rl + (1 - D0) * Rs + n**2 * D0 * Rp);
                CfList.append(a / b)
            return CfList
        
        RlList = getRlList()
        D0List = getD0List(RlList)
        LmList = getLmList(RlList, D0List)
        CfList = getCfList(RlList, D0List)
        
        info(f"Resistive loads that represent {PoutList} are: {RlList}")
        info("-----------------------------\r\n")
        info(f"Needed magnetizing inductances: {LmList}")
        info("-----------------------------\r\n")
        info(f"Needed output filtering capacitances: {CfList}")
        info("-----------------------------\r\n")
        
        Lm = 20e-3
        Cf = 5e-3
        
        wc = 2 * np.pi * fs/10
        
        
        # SYSTEM CALCULATION
        D0 = D0List[1]  # no matter what you choose, load will only differ and
        Rl = RlList[1]  # the task of regulation is to compensate that difference
        
        A11 = -(n**2 * D0 * Rp + (1 - D0) * Rs) / (n**2 * Lm)
        A12 = -(1 - D0) / (n * Lm)
        A21 = (1 - D0) / (n * Cf)
        A22 = -1 / (Rl * Cf)
        A = [[A11, A12], [A21, A22]]
        
        B11 = D0 / Lm
        B12 = Vin * ((1 - D0) * Rl + Rs) / (Lm * ((1 - D0) ** 2 * Rl + (1 - D0) * Rs + n**2 * D0 * Rp))
        B21 = 0
        B22 = -(n * D0 * Vin) / (Cf * ((1 - D0) ** 2 * Rl + (1 - D0) * Rs + n**2 * D0 * Rp))
        B = [[B11, B12], [B21, B22]]
        
        B1 = [[B11], [B21]]
        B2 = [[B12], [B22]]
        D1 = [[0]]
        D2 = [[0]]
        
        C = [0, 1]
        D = [0, 0]
        
        sys1 = ct.ss(A, B1, C, D1)
        GVV = ct.ss2tf(sys1)
        
        sys2 = ct.ss(A, B2, C, D2)
        GDV = ct.ss2tf(sys2)
        
        wc = 2 * np.pi * fs/10
        
        mag, _, _ = GDV.freqresp(wc)
        KReg = 1 / mag
        
        theta = np.deg2rad(89)
        p = np.sqrt((1 + np.sin(theta)) / (1 - np.sin(theta)))
        
        GLeadNum = [1, p/wc]
        GLeadDen = [1, 1/(p * wc)]
        
        GLag2Num = [1, wc/10]
        GLag2Den = [1, 0]
        
        KVinComp = ct.dcgain(GVV / GDV)
    ENDCODE
}
