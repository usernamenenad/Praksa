version = 4.2

//
// Saved by sw version: 2024.1
//

model "test" {
    configuration {
        hil_device = "VHIL+"
        hil_configuration_id = 1
        simulation_method = exact
        simulation_time_step = 20e-6
        simulation_discret_scaling = 1.0
        dsp_timer_periods = 100e-6, 50e-3
        ss_calc_method = "systematic elimination"
        enb_pole_shift = True
        enb_gds_oversampling = True
        show_modes = False
        device_ao_limit_enable = False
        reset_analog_outputs_on_sim_stop = True
        reset_analog_outputs_on_sim_stop_mode = Offset values
        reset_digital_outputs_on_sim_stop = True
        vhil_adio_loopback = False
        cpl_stb = False
        enb_dep_sw_detect = False
        code_section = "internal memory"
        data_section = "internal memory"
        sys_sp_rate_1 = 0.0001
        sys_sp_rate_2 = 0.05
        sys_real_type_precision = "default"
        user_real_type_precision = "default"
        sys_cpu_optimization = "high"
        user_cpu_optimization = "high"
        user_cpu_part_option = "default"
        matrix_based_reduction = True
        cpl_dynamics_analysis = False
        export_ss_to_pickle = False
        ground_scope_core = False
        dss_num_tol = 1e-15
        cce_platform = "generic"
        cce_use_relative_names = False
        cce_type_mapping_real = "double"
        cce_type_mapping_uint = "unsigned int"
        cce_type_mapping_int = "int"
        cce_platform = "generic"
        cce_use_relative_names = False
        cce_type_mapping_real = "double"
        cce_type_mapping_uint = "unsigned int"
        cce_type_mapping_int = "int"
        cce_directory = ""
        cce_custom_type_int = ""
        cce_custom_type_uint = ""
        cce_custom_type_real = ""
        tunable_params = "component defined"
        sp_compiler_type = "C compiler"
        sig_stim = "off"
        export_resource_list = ""
        export_dependency_list = ""
        excluded_resource_list = ""
        export_out_file = ""
        export_lock_top_level = True
        export_encrypt_library = True
        export_encrypt_resources = True
        dae_solver = "BDF"
        max_sim_step = 1e-4
        simulation_time = 1.0
        abs_tol = 1e-3
        rel_tol = 1e-3
        init_sim_step = 1e-6
        r_on_sw = 1e-3
        v_on_diode = 0.2
        data_sampling_rate = 0
        feedthrough_validation_error_level = error
    }

    component Subsystem Root {
        component "core/Flyback" Flyback {
            L1 = "1e-9"
            L2 = "1e-9"
            Lm = "Lm"
            R1 = "1e-9"
            R2 = "1e-9"
            Rm = "1000000"
            carrier_freq = "fs"
            ctrl_src = "Internal modulator"
            d_time = "0"
            n1 = "100"
            n2 = "37"
            ref_sig_min_max = "[0.0, 1.0]"
            signal_access = "Inherit"
        }
        [
            position = 8464, 8288
            size = 144, 256
        ]

        component "core/Capacitor" C2 {
            capacitance = "C2"
            signal_access = "Inherit"
        }
        [
            position = 8648, 8240
            rotation = right
        ]

        component "core/Voltage Measurement" Vout {
            signal_access = "Inherit"
        }
        [
            position = 8960, 8240
            rotation = right
            size = 64, 32
        ]

        component "core/SCADA Input" "duty ratio" {
            max = "1"
            min = "0"
            signal_access = "Inherit"
            unit = ""
        }
        [
            position = 8256, 8048
        ]

        component "core/SCADA Input" "set power" {
            unit = ""
        }
        [
            position = 8912, 8048
            rotation = down
        ]

        component "core/SCADA Input" enable {
            max = "1"
            min = "0"
            signal_access = "Inherit"
            unit = ""
        }
        [
            position = 8256, 8120
        ]

        component "core/Single Phase Diode Rectifier" "Single Phase Diode Rectifier" {
        }
        [
            position = 8008, 8288
            size = 127, 256
        ]

        component "core/Voltage Source" Vsource {
            init_frequency = "f"
            init_rms_value = "Vrms"
            init_source_nature = "Sine"
        }
        [
            position = 7792, 8288
            rotation = right
        ]

        component "core/Voltage Measurement" Vin {
        }
        [
            position = 8240, 8288
            rotation = right
            size = 64, 32
        ]

        component "core/Inductor" L1 {
            inductance = "1e-5"
            signal_access = "Inherit"
        }
        [
            position = 7856, 8192
        ]

        component "core/Capacitor" C1 {
            capacitance = "2e-3"
            signal_access = "Inherit"
        }
        [
            position = 8152, 8288
            rotation = right
        ]

        component "core/Probe" "duty ratio probe" {
        }
        [
            position = 8544, 8048
        ]

        component "core/Probe" "set power probe" {
        }
        [
            position = 8912, 8120
        ]

        component "core/Resistor" Req {
            resistance = "0.00001"
        }
        [
            position = 8312, 8192
        ]

        component "core/Variable Resistor" RL1 {
        }
        [
            position = 8768, 8240
            rotation = left
            size = 64, 48
        ]

        junction Junction26 pe
        [
            position = 8240, 8384
        ]

        junction Junction27 pe
        [
            position = 8152, 8192
        ]

        junction Junction28 pe
        [
            position = 8152, 8384
        ]

        junction Junction36 sp
        [
            position = 8472, 8048
        ]

        junction Junction38 pe
        [
            position = 8240, 8192
        ]

        junction Junction40 pe
        [
            position = 8648, 8192
        ]

        junction Junction41 pe
        [
            position = 8648, 8288
        ]

        junction Junction42 pe
        [
            position = 8768, 8192
        ]

        junction Junction43 pe
        [
            position = 8768, 8288
        ]

        junction Junction44 sp
        [
            position = 8728, 8120
        ]

        connect enable.out Flyback.En as Connection163
        connect Vsource.n_node "Single Phase Diode Rectifier.b_in" as Connection303
        connect Junction26 Flyback.b_in as Connection391
        [
            breakpoints = 8248, 8384; 8248, 8384; 8264, 8384; 8264, 8384; 8264, 8384; 8312, 8384; 8312, 8384
        ]
        connect Vin.n_node Junction26 as Connection392
        connect L1.n_node "Single Phase Diode Rectifier.a_in" as Connection393
        connect Junction27 "Single Phase Diode Rectifier.pos_out" as Connection396
        connect C1.p_node Junction27 as Connection397
        connect "Single Phase Diode Rectifier.neg_out" Junction28 as Connection398
        connect Junction28 Junction26 as Connection399
        [
            breakpoints = 8160, 8384; 8160, 8384; 8184, 8384; 8208, 8384
        ]
        connect C1.n_node Junction28 as Connection400
        connect "duty ratio.out" Junction36 as Connection472
        [
            breakpoints = 8464, 8048
        ]
        connect Junction36 Flyback.In as Connection473
        connect "duty ratio probe.in" Junction36 as Connection474
        connect Req.n_node Flyback.a_in as Connection493
        connect Vin.p_node Junction38 as Connection494
        connect Junction38 Junction27 as Connection495
        [
            breakpoints = 8240, 8192; 8240, 8192; 8184, 8192; 8184, 8192; 8184, 8192; 8152, 8192
        ]
        connect Req.p_node Junction38 as Connection496
        connect L1.p_node Vsource.p_node as Connection503
        connect Flyback.a_out Junction40 as Connection511
        connect C2.p_node Junction40 as Connection513
        connect C2.n_node Junction41 as Connection516
        connect Junction41 Flyback.b_out as Connection517
        [
            breakpoints = 8648, 8288; 8648, 8288; 8648, 8288; 8648, 8288; 8648, 8288; 8648, 8288
        ]
        connect Junction40 Junction42 as Connection525
        [
            breakpoints = 8648, 8192
        ]
        connect Junction42 Vout.p_node as Connection526
        [
            breakpoints = 8776, 8192; 8776, 8192; 8792, 8192; 8792, 8192; 8800, 8192; 8800, 8192; 8800, 8192
        ]
        connect RL1.n_node Junction42 as Connection527
        connect Vout.n_node Junction43 as Connection528
        [
            breakpoints = 8776, 8288
        ]
        connect Junction43 Junction41 as Connection529
        connect RL1.p_node Junction43 as Connection530
        connect "set power.out" Junction44 as Connection532
        connect Junction44 RL1.In as Connection533
        connect "set power probe.in" Junction44 as Connection534
    }

    default {
        "core/Capacitor" {
            signal_access = "inherit"
            capacitance = "1e-6"
            initial_voltage = "0"
            pole_shift_ignore = "False"
            visible = "True"
        }

        "core/Inductor" {
            signal_access = "inherit"
            inductance = "1e-3"
            initial_current = "0.0"
            pole_shift_ignore = "False"
            visible = "True"
        }

        "core/Probe" {
            signal_access = "inherit"
            addr = "0"
            override_signal_name = "False"
            signal_name = ""
            signal_type = "generic"
            streaming_en = "False"
            streaming_er_idx = "0"
            execution_rate = "inherit"
        }

        "core/Resistor" {
            resistance = "1"
            param_set = ""
        }

        "core/SCADA Input" {
            signal_access = "inherit"
            addr = "0"
            format = "real"
            override_signal_name = "False"
            signal_name = ""
            signal_type = "real"
            min = "-1e6"
            max = "1e6"
            def_value = "0"
            unit = " "
            execution_rate = "100e-6"
        }

        "core/Voltage Source" {
            sig_input = "False"
            type = "signal generator"
            param_set = "1phase"
            parent_label = ""
            addr = "0"
            spc_nb = "0"
            execution_rate = "100e-6"
            cpd_visible = "True"
            enable_snb = "False"
            snb_type = "R2"
            R2 = "0.0"
            L1 = "0.1"
            override_signal_name = "False"
            signal_name = ""
            init_source_nature = "Constant"
            init_const_value = "0.0"
            init_rms_value = "0.0"
            init_frequency = "50.0"
            init_phase = "0.0"
        }

        "core/Flyback" {
            signal_access = "inherit"
            ctrl_src = "Digital inputs"
            op_mode = "Fixed carrier frequency"
            carrier_freq = "10000.0"
            carr_ph_offset = "0.0"
            d_time = "5e-6"
            ref_sig_min_max = "[-1.0, 1.0]"
            load_mode = "on min"
            execution_rate = "inherit"
            S1 = "1"
            S1_logic = "active high"
            show_monitoring = "False"
            n1 = "1"
            n2 = "1"
            L1 = "0.001"
            I1 = "0"
            L2 = "0.001"
            I2 = "0"
            Lm = "5"
            R1 = "0.1"
            R2 = "0.1"
            Rm = "1e4"
            pwm_enabling = "False"
            pwm_enable_di = "13"
            pwm_enable_inv = "active high"
        }

        "core/Single Phase Diode Rectifier" {
            signal_access = "inherit"
            FSM_select = "converter"
            show_monitoring = "False"
            dynamic_ac_voltage = "False"
            pesb_optimization = "True"
            predictive_diode_turn_off = "False"
        }

        "core/Variable Resistor" {
            inductance = "1e-3"
            initial_current = "0.0"
            hide_int_meas = "False"
        }

        "core/Voltage Measurement" {
            signal_access = "inherit"
            bw_limit = "False"
            frequency = "10e3"
            comparator_enable = "False"
            operator = "greater"
            threshold = "0"
            cmp_abs_value = "False"
            feed_forward = "false"
            sig_output = "False"
            sig_output_filt_and_full_bw = "False"
            execution_rate = "100e-6"
            addr = "0"
            nd_msr_estimation = "false"
            dev_cpl_msr = "false"
            host_device = "0"
            output_to_device = "0"
            dev_cpl_index = "0"
            dev_cpl_var_nb = "0"
            visible = "True"
            override_signal_name = "False"
            signal_name = ""
        }
    }

    CODE model_init
        # Numpy module is imported as 'np'
        # Scipy module is imported as 'sp'
        # The Schematic API is imported as 'mdl'
        # To get the model file path, use 'mdl.get_model_file_path()'
        # To print information to the console, use info()
        
        Vrms = 230
        Vin = Vrms * np.sqrt(2)
        R = 50
        n = 0.37
        f = 50
        fs = 2500
        PlossT = 0.01
        k1 = 0.01
        k2 = 0.01
        
        
        def get_duty_ratio(Vout: float, Pout: float):
            return np.roots(
                [
                    R * PlossT,
                    (n * Vin + Vout) * (Vout + R * Pout / Vout) - R * PlossT,
                    -(Vout**2) - R * Pout,
                ]
            )[1]
        
        
        # Magnetizing inductance
        def get_inductance(Vout: float, Pout: float, D: float):
            return (R * Vout * (1 - D) ** 2) / (2 * (n**2) * fs * (Vout + R * Pout / Vout))
        
        
        def get_minimum_inductance(Vout: list[float], Pout: list[float]):
            Lm_min = max(
                [
                    get_inductance(vout, pout, get_duty_ratio(vout, pout))
                    for vout in Vout
                    for pout in Pout
                ]
            )
            info(f"Minimum magnetizing inductance Lm for CCM is: {Lm_min}.")
            return Lm_min
        
        
        # Capacitive filter C1
        def get_capacitance_C1(Vout: float, Pout: float, D: float):
            return (D * n * (Vout + R * Pout / Vout)) / (2 * k1 * f * Vin * R * (1 - D))
        
        
        def get_minimum_capacitance_C1(Vout: list[float], Pout: list[float]):
            C1_min = max(
                [
                    get_capacitance_C1(vout, pout, get_duty_ratio(vout, pout))
                    for vout in Vout
                    for pout in Pout
                ]
            )
            info(f"Minimum capacitance C1 required for ripple to be k1 = {k1} is: {C1_min}.")
            return C1_min
        
        # Capacitive filter C2
        def get_capacitance_C2(Vout: float, Pout: float, D: float):
            return D * (R * Pout / Vout - Vout) / (2 * k2 * fs * R * Vout)
        
        
        def get_minimum_capacitance_C2(Vout: list[float], Pout: list[float]):
            C2_min = max(
                [
                    get_capacitance_C2(vout, pout, get_duty_ratio(vout, pout))
                    for vout in Vout
                    for pout in Pout
                ]
            )
            info(f"Minimum capacitance C2 required for ripple to be k2 = {k2} is: {C2_min}.")
            return C2_min
        
        
        Vout = [5, 12]
        Pout = [7.5, 100]
        C1 = round(get_minimum_capacitance_C1(Vout, Pout) + 1e-2, 3)
        info(f"For better dynamics, we're choosing C1 to be {C1}F.")
        info("---------------------------------------")
        C2 = round(get_minimum_capacitance_C2(Vout, Pout) + 1e-2, 3)
        info(f"For better dynamics, we're choosing C1 to be {C2}F.")
        info("---------------------------------------")
        Lm = round(get_minimum_inductance(Vout, Pout) + 1e-2, 3)
        info(f"For better dynamics, we're choosing Lm to be {Lm}H.")
        info("---------------------------------------")
    ENDCODE
}
