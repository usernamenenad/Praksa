version = 4.2

//
// Saved by sw version: 2024.1
//

model "zad2b" {
    configuration {
        hil_device = "VHIL+"
        hil_configuration_id = 1
        simulation_method = exact
        simulation_time_step = 1e-6
        simulation_discret_scaling = 1.0
        dsp_timer_periods = 100e-6, 50e-3
        ss_calc_method = "systematic elimination"
        enb_pole_shift = True
        enb_gds_oversampling = True
        show_modes = False
        device_ao_limit_enable = False
        reset_analog_outputs_on_sim_stop = True
        reset_analog_outputs_on_sim_stop_mode = Offset values
        reset_digital_outputs_on_sim_stop = True
        vhil_adio_loopback = False
        cpl_stb = False
        enb_dep_sw_detect = False
        code_section = "internal memory"
        data_section = "internal memory"
        sys_sp_rate_1 = 0.0001
        sys_sp_rate_2 = 0.05
        sys_real_type_precision = "default"
        user_real_type_precision = "default"
        sys_cpu_optimization = "high"
        user_cpu_optimization = "high"
        user_cpu_part_option = "default"
        matrix_based_reduction = True
        cpl_dynamics_analysis = False
        export_ss_to_pickle = False
        ground_scope_core = False
        dss_num_tol = 1e-15
        cce_platform = "generic"
        cce_use_relative_names = False
        cce_type_mapping_real = "double"
        cce_type_mapping_uint = "unsigned int"
        cce_type_mapping_int = "int"
        cce_platform = "generic"
        cce_use_relative_names = False
        cce_type_mapping_real = "double"
        cce_type_mapping_uint = "unsigned int"
        cce_type_mapping_int = "int"
        cce_directory = ""
        cce_custom_type_int = ""
        cce_custom_type_uint = ""
        cce_custom_type_real = ""
        tunable_params = "component defined"
        sp_compiler_type = "C compiler"
        sig_stim = "off"
        export_resource_list = ""
        export_dependency_list = ""
        excluded_resource_list = ""
        export_out_file = ""
        export_lock_top_level = True
        export_encrypt_library = True
        export_encrypt_resources = True
        dae_solver = "BDF"
        max_sim_step = 1e-4
        simulation_time = 1.0
        abs_tol = 1e-3
        rel_tol = 1e-3
        init_sim_step = 1e-6
        r_on_sw = 1e-3
        v_on_diode = 0.2
        data_sampling_rate = 0
        feedthrough_validation_error_level = error
    }

    component Subsystem Root {
        component "core/Flyback" Flyback1 {
            L1 = "1e-9"
            L2 = "1e-9"
            Lm = "Lm"
            R1 = "Rp"
            R2 = "Rs"
            Rm = "1e6"
            carrier_freq = "fs"
            ctrl_src = "Internal modulator"
            d_time = "0"
            n1 = "1/n"
            ref_sig_min_max = "[0.0, 1.0]"
            signal_access = "Inherit"
        }
        [
            position = 8552, 8312
            size = 144, 256
        ]

        component "core/Voltage Source" Vin {
            init_const_value = "Vin"
        }
        [
            position = 8224, 8312
            rotation = right
        ]

        component "core/Capacitor" Cout {
            capacitance = "Cout"
            signal_access = "Inherit"
        }
        [
            position = 8760, 8264
            rotation = right
        ]

        component "core/SCADA Input" "Enable flyback" {
            unit = ""
        }
        [
            position = 8400, 8136
        ]

        component "core/Voltage Measurement" Vout {
        }
        [
            position = 9000, 8264
            rotation = right
            size = 64, 32
        ]

        component "core/Constant" Constant1 {
            value = "D_list[1]"
        }
        [
            position = 8400, 8072
        ]

        component "core/Resistor" R1 {
            resistance = "0.25"
        }
        [
            position = 8856, 8264
            rotation = right
        ]

        junction Junction1 pe
        [
            position = 8760, 8216
        ]

        junction Junction2 pe
        [
            position = 8760, 8312
        ]

        junction Junction3 pe
        [
            position = 8856, 8216
        ]

        junction Junction4 pe
        [
            position = 8856, 8312
        ]

        connect Vin.p_node Flyback1.a_in as Connection1
        connect Vin.n_node Flyback1.b_in as Connection2
        connect Flyback1.a_out Junction1 as Connection5
        connect Junction1 Cout.p_node as Connection6
        connect Flyback1.b_out Junction2 as Connection8
        connect Junction2 Cout.n_node as Connection9
        connect "Enable flyback.out" Flyback1.En as Connection17
        connect Constant1.out Flyback1.In as Connection18
        connect Vout.p_node Junction3 as Connection21
        [
            breakpoints = 8864, 8216
        ]
        connect Junction3 Junction1 as Connection22
        connect R1.p_node Junction3 as Connection23
        connect Junction2 Junction4 as Connection24
        [
            breakpoints = 8760, 8312
        ]
        connect Junction4 Vout.n_node as Connection25
        [
            breakpoints = 8864, 8312
        ]
        connect R1.n_node Junction4 as Connection26
    }

    default {
        "core/Capacitor" {
            signal_access = "inherit"
            capacitance = "1e-6"
            initial_voltage = "0"
            pole_shift_ignore = "False"
            visible = "True"
        }

        "core/Constant" {
            value = "1"
            signal_type = "real"
            execution_rate = "100e-6"
            _tunable = "False"
        }

        "core/Resistor" {
            resistance = "1"
            param_set = ""
        }

        "core/SCADA Input" {
            signal_access = "inherit"
            addr = "0"
            format = "real"
            override_signal_name = "False"
            signal_name = ""
            signal_type = "real"
            min = "-1e6"
            max = "1e6"
            def_value = "0"
            unit = " "
            execution_rate = "100e-6"
        }

        "core/Voltage Source" {
            sig_input = "False"
            type = "signal generator"
            param_set = "1phase"
            parent_label = ""
            addr = "0"
            spc_nb = "0"
            execution_rate = "100e-6"
            cpd_visible = "True"
            enable_snb = "False"
            snb_type = "R2"
            R2 = "0.0"
            L1 = "0.1"
            override_signal_name = "False"
            signal_name = ""
            init_source_nature = "Constant"
            init_const_value = "0.0"
            init_rms_value = "0.0"
            init_frequency = "50.0"
            init_phase = "0.0"
        }

        "core/Flyback" {
            signal_access = "inherit"
            ctrl_src = "Digital inputs"
            op_mode = "Fixed carrier frequency"
            carrier_freq = "10000.0"
            carr_ph_offset = "0.0"
            d_time = "5e-6"
            ref_sig_min_max = "[-1.0, 1.0]"
            load_mode = "on min"
            execution_rate = "inherit"
            S1 = "1"
            S1_logic = "active high"
            show_monitoring = "False"
            n1 = "1"
            n2 = "1"
            L1 = "0.001"
            I1 = "0"
            L2 = "0.001"
            I2 = "0"
            Lm = "5"
            R1 = "0.1"
            R2 = "0.1"
            Rm = "1e4"
            pwm_enabling = "False"
            pwm_enable_di = "13"
            pwm_enable_inv = "active high"
        }

        "core/Voltage Measurement" {
            signal_access = "inherit"
            bw_limit = "False"
            frequency = "10e3"
            comparator_enable = "False"
            operator = "greater"
            threshold = "0"
            cmp_abs_value = "False"
            feed_forward = "false"
            sig_output = "False"
            sig_output_filt_and_full_bw = "False"
            execution_rate = "100e-6"
            addr = "0"
            nd_msr_estimation = "false"
            dev_cpl_msr = "false"
            host_device = "0"
            output_to_device = "0"
            dev_cpl_index = "0"
            dev_cpl_var_nb = "0"
            visible = "True"
            override_signal_name = "False"
            signal_name = ""
        }
    }

    CODE model_init
        # Numpy module is imported as 'np'
        # Scipy module is imported as 'sp'
        # The Schematic API is imported as 'mdl'
        # To get the model file path, use 'mdl.get_model_file_path()'
        # To print information to the console, use info()
        
        # Model Parameters
        n = 0.2
        Vin = 230 * np.sqrt(2)
        Vout = 5
        Pout_min = 7.5
        Pout_max = 100
        Pout_list = [Pout_min, Pout_max]
        PlossT = 0.5
        fs = 2500
        output_ripple = 0.03
        
        # Calculations of parameters
        
        # Duty Ratio
        """
        This is a list where the duty ratio's for two marginal output powers will be.
        They will not differ that much - that's because we want to have constant
        output power, and the output current will actually change.
        """
        D_list = []
        for Pout in Pout_list:
            a = Vout * (1 + PlossT / Pout);
            b = n * Vin + a;
            D_list.append(a / b);
        
        # Equivallent transformer resistance
        """
        Equivallent transformer resistance is calculated based on how much power
        can be dissipated on transformer during one switching frequency. Obviously,
        for different output powers, we will have different dissipation, 
        so we'll calculate the maximal allowed equivallent resistance. Then,
        we can carefully choose actual transformer windings' resistances
        based on this calculated equivallent resistance.
        """
        Req_list = []
        for i in range(len(Pout_list)):
            Pout = Pout_list[i]
            D = D_list[i]
            a = (1 - D) * Vout
            b = n * Pout;
            Req_list.append(PlossT * (a / b)**2)
        
        """
        We can now choose an arbitrary primary or secondary winding's resistance,
        and choosing one of them will yield another. Equation for Req is given by
        
        Req = D * Rp + (1 - D) / n**2 * Rs
        
        We'll choose smartly and say that Rp = Req / D. That will make Rs = 0. 
        The user of the model is allowed to modify the resistances below, 
        as long as its' choices satisfy the equation above.
        """
        Req = min(Req_list)
        iReq = Req_list.index(Req)
        Rp = Req / D_list[i]
        Rs = 1e-9 # Equivallent to saying Rs = 0 in Typhoon Hil software.
        
        # Steady state values of magnetizing current
        ILm_list = []
        for i in range(len(Pout_list)):
            Pout = Pout_list[i]
            D = D_list[i]
            a = n * Pout
            b = (1 - D) * Vout
            ILm_list.append(a / b)
            
        # Choosing the magnetizing inductance
        """
        For this model, it is chosen for flyback to work in continuous conduction mode.
        This statement is described by the equation
        
        ILm > dILm
        
        where dILm is the current ripple. For different output powers,
        we will have different solutions for the value of magnetizing inductance,
        and the task is to find the solution which for all output powers 
        satisfies the equation above.
        """
        Lm_list = []
        for i in range(len(Pout_list)):
            Pout = Pout_list[i]
            D = D_list[i]
            ILm = ILm_list[i]
            Rload = Vout ** 2 / Pout
            a = (1 - D)**2 * D * Rload * Vin
            b = 2 * fs * ILm * ((1 - D)**2 * Rload + n**2 * Req)
            Lm_list.append(a / b)
            
        Lm = max(Lm_list) + 5e-3
        info(Lm)
        
        # Choosing the output capacitance
        Cout_list = []
        for i in range(len(Pout_list)):
            Pout = Pout_list[i]
            D = D_list[i]
            a = n * D**2 * (1 - D) * Vin
            b = 2 * output_ripple * fs * Vout * ((1 - D)**2 * Rload + n**2 * Req)
            Cout_list.append(a / b)
        
        Cout = max(Cout_list) + 5e-3
        info(Cout)
    ENDCODE
}
