version = 4.2

//
// Saved by sw version: 2024.1
//

model "zad2b" {
    configuration {
        hil_device = "VHIL+"
        hil_configuration_id = 1
        simulation_method = exact
        simulation_time_step = 1e-6
        simulation_discret_scaling = 1.0
        dsp_timer_periods = 100e-6, 50e-3
        ss_calc_method = "systematic elimination"
        enb_pole_shift = True
        enb_gds_oversampling = True
        show_modes = False
        device_ao_limit_enable = False
        reset_analog_outputs_on_sim_stop = True
        reset_analog_outputs_on_sim_stop_mode = Offset values
        reset_digital_outputs_on_sim_stop = True
        vhil_adio_loopback = False
        cpl_stb = False
        enb_dep_sw_detect = False
        code_section = "internal memory"
        data_section = "internal memory"
        sys_sp_rate_1 = 0.0001
        sys_sp_rate_2 = 0.05
        sys_real_type_precision = "default"
        user_real_type_precision = "default"
        sys_cpu_optimization = "high"
        user_cpu_optimization = "high"
        user_cpu_part_option = "default"
        matrix_based_reduction = True
        cpl_dynamics_analysis = False
        export_ss_to_pickle = False
        ground_scope_core = False
        dss_num_tol = 1e-15
        cce_platform = "generic"
        cce_use_relative_names = False
        cce_type_mapping_real = "double"
        cce_type_mapping_uint = "unsigned int"
        cce_type_mapping_int = "int"
        cce_platform = "generic"
        cce_use_relative_names = False
        cce_type_mapping_real = "double"
        cce_type_mapping_uint = "unsigned int"
        cce_type_mapping_int = "int"
        cce_directory = ""
        cce_custom_type_int = ""
        cce_custom_type_uint = ""
        cce_custom_type_real = ""
        tunable_params = "component defined"
        sp_compiler_type = "C compiler"
        sig_stim = "off"
        export_resource_list = ""
        export_dependency_list = ""
        excluded_resource_list = ""
        export_out_file = ""
        export_lock_top_level = True
        export_encrypt_library = True
        export_encrypt_resources = True
        dae_solver = "BDF"
        max_sim_step = 1e-4
        simulation_time = 1.0
        abs_tol = 1e-3
        rel_tol = 1e-3
        init_sim_step = 1e-6
        r_on_sw = 1e-3
        v_on_diode = 0.2
        data_sampling_rate = 0
        feedthrough_validation_error_level = error
    }

    component Subsystem Root {
        component "core/Flyback" Flyback1 {
            L1 = "1e-9"
            L2 = "1e-9"
            Lm = "Lm"
            R1 = "Rp"
            R2 = "Rs"
            Rm = "1e7"
            carrier_freq = "fs"
            ctrl_src = "Internal modulator"
            d_time = "0"
            n1 = "1/n"
            ref_sig_min_max = "[0.0, 1.0]"
            signal_access = "Inherit"
        }
        [
            position = 8552, 8312
            size = 144, 256
        ]

        component "core/Capacitor" Cout {
            capacitance = "Cout"
            signal_access = "Inherit"
        }
        [
            position = 8760, 8264
            rotation = right
        ]

        component "core/SCADA Input" "Enable flyback" {
            execution_rate = "Ts"
            max = "1"
            min = "0"
            signal_access = "Inherit"
            unit = ""
        }
        [
            position = 8400, 8136
        ]

        component "core/Voltage Measurement" Vout {
            execution_rate = "Ts"
            sig_output = "True"
            signal_access = "Inherit"
        }
        [
            position = 9088, 8264
            rotation = right
            size = 64, 32
        ]

        component "core/Variable Resistor" Rload {
            inductance = "1e-4"
        }
        [
            position = 8944, 8264
            rotation = right
            size = 64, 48
        ]

        component "core/SCADA Input" "Output power" {
            def_value = "7.5"
            execution_rate = "Ts"
            max = "100"
            min = "7.5"
            signal_access = "Inherit"
            unit = ""
        }
        [
            position = 8568, 7960
        ]

        component "core/Product" Product1 {
            signs = "*/"
        }
        [
            position = 8688, 7952
            hide_name = True
        ]

        component "core/Constant" "Referent output voltage" {
            execution_rate = "Ts"
            value = "Vout"
        }
        [
            position = 8232, 8592
        ]

        component "core/Sum" Sum1 {
            signs = "+-"
        }
        [
            position = 8560, 8688
            hide_name = True
        ]

        component "core/PID controller" PI {
            controller_type = "PI"
            filt_coef = "68"
            kd = "-4.89275e-5"
            ki = "0.1005"
            kp = "3.86e-5"
            lower_sat_lim = "0"
        }
        [
            position = 8688, 8688
        ]

        component "core/Product" Product2 {
        }
        [
            position = 8568, 7872
            hide_name = True
        ]

        component "core/Signal Controlled Voltage Source" Vin {
        }
        [
            position = 8312, 8312
            rotation = right
            size = 64, 32
        ]

        component "core/SCADA Input" "Enable disturbance" {
            execution_rate = "Ts"
            format = "int"
            max = "1"
            min = "0"
            signal_access = "Inherit"
            signal_type = "int"
            unit = ""
        }
        [
            position = 7888, 8224
        ]

        component "core/Limit" Limit1 {
            lower_limit = "0"
            upper_limit = "1"
        }
        [
            position = 8936, 8696
            hide_name = True
        ]

        component "core/Sum" Sum2 {
        }
        [
            position = 8832, 8696
            hide_name = True
        ]

        component "core/Gain" "Disturbance Compensator" {
            gain = "dist_comp_gain"
        }
        [
            position = 8632, 8792
        ]

        component "core/Sum" Sum3 {
            signs = "+-"
        }
        [
            position = 8456, 8792
            hide_name = True
        ]

        component "core/Constant" "Referent input voltage2" {
            execution_rate = "Ts"
            value = "Vin"
        }
        [
            position = 8336, 8784
        ]

        component "core/Sinusoidal Source" Disturbance {
            _tunable = "True"
            amplitude = "0.2 * Vin / np.sqrt(2)"
            execution_rate = "Ts"
            frequency = "5"
        }
        [
            position = 7888, 8304
        ]

        component "core/Constant" "Referent input voltage1" {
            execution_rate = "Ts"
            value = "Vin"
        }
        [
            position = 8096, 8224
        ]

        component "core/Sum" Sum4 {
        }
        [
            position = 8208, 8312
            hide_name = True
        ]

        component "core/Signal switch" "Signal switch1" {
            criterion = "ctrl != threshold"
            threshold = "0"
        }
        [
            position = 8000, 8320
            hide_name = True
        ]

        component "core/Constant" Constant1 {
            execution_rate = "Ts"
            value = "0"
        }
        [
            position = 7888, 8384
        ]

        component "core/Probe" "Input voltage measurement" {
        }
        [
            position = 8336, 8496
        ]

        component "core/Rate Limiter" "Rate Limiter1" {
            falling_limit = "-10"
            rising_limit = "10"
        }
        [
            position = 8776, 7952
            hide_name = True
        ]

        component "core/Sum" Sum5 {
            signs = "+-"
        }
        [
            position = 9016, 7856
        ]

        component "core/Gain" Gain1 {
        }
        [
            position = 9144, 7856
        ]

        component "core/Low-Pass Filter" "Low-Pass Filter1" {
        }
        [
            position = 8920, 7880
        ]

        tag "Calculate output load (Goto)" {
            value = "CalculateRload"
            scope = local
            kind = sp
            direction = in
        }
        [
            position = 8432, 8592
            hide_name = True
            size = 60, 20
        ]

        tag "Calculate output load (From)" {
            value = "CalculateRload"
            scope = local
            kind = sp
            direction = out
        }
        [
            position = 8416, 7864
            size = 60, 20
        ]

        tag "Output Voltage Measure (Goto)" {
            value = "OutputVoltageMeasure"
            scope = local
            kind = sp
            direction = in
        }
        [
            position = 9200, 8264
            size = 60, 20
        ]

        tag "Output Voltage Measure (From)" {
            value = "OutputVoltageMeasure"
            scope = local
            kind = sp
            direction = out
        }
        [
            position = 8328, 8696
            size = 60, 20
        ]

        tag "Duty ratio (Goto)" {
            value = "ControlSignal"
            scope = local
            kind = sp
            direction = in
        }
        [
            position = 9032, 8696
            size = 60, 20
        ]

        tag "Duty ratio (From)" {
            value = "ControlSignal"
            scope = local
            kind = sp
            direction = out
        }
        [
            position = 8416, 8048
            size = 60, 20
        ]

        tag "Input Voltage (From)" {
            value = "InputVoltage"
            scope = local
            kind = sp
            direction = out
        }
        [
            position = 8336, 8848
            size = 60, 20
        ]

        tag "Input Voltage (Goto)" {
            value = "InputVoltage"
            scope = local
            kind = sp
            direction = in
        }
        [
            position = 8336, 8440
            size = 60, 20
        ]

        junction Junction2 pe
        [
            position = 8760, 8312
        ]

        junction Junction4 pe
        [
            position = 8944, 8312
        ]

        junction Junction5 sp
        [
            position = 8360, 8592
        ]

        junction Junction6 sp
        [
            position = 8512, 7864
        ]

        junction Junction7 sp
        [
            position = 8256, 8312
        ]

        junction Junction8 sp
        [
            position = 8256, 8440
        ]

        junction Junction11 sp
        [
            position = 8736, 7952
        ]

        junction Junction12 pe
        [
            position = 8760, 8216
        ]

        junction Junction13 pe
        [
            position = 8944, 8216
        ]

        junction Junction14 sp
        [
            position = 8736, 7888
        ]

        connect Flyback1.b_out Junction2 as Connection8
        connect Junction2 Cout.n_node as Connection9
        connect "Enable flyback.out" Flyback1.En as Connection17
        connect Junction2 Junction4 as Connection33
        [
            breakpoints = 8760, 8312; 8760, 8312
        ]
        connect Junction4 Vout.n_node as Connection34
        [
            breakpoints = 8944, 8312; 8952, 8312
        ]
        connect Rload.n_node Junction4 as Connection35
        connect "Output power.out" Product1.in1 as Connection38
        connect Vout.out "Output Voltage Measure (Goto)" as Connection40
        connect "Output Voltage Measure (From)" Sum1.in1 as Connection41
        connect Junction5 "Calculate output load (Goto)" as Connection43
        connect Sum1.in Junction5 as Connection44
        connect Sum1.out PI.in as Connection45
        connect "Duty ratio (From)" Flyback1.In as Connection47
        connect Product2.out Product1.in as Connection48
        connect "Calculate output load (From)" Junction6 as Connection50
        connect Junction6 Product2.in as Connection51
        connect Product2.in1 Junction6 as Connection52
        connect PI.out Sum2.in as Connection57
        connect Sum2.out Limit1.in as Connection58
        connect Limit1.out "Duty ratio (Goto)" as Connection59
        connect Sum3.out "Disturbance Compensator.in" as Connection66
        connect "Input Voltage (From)" Sum3.in1 as Connection67
        connect "Referent input voltage2.out" Sum3.in as Connection68
        connect "Referent input voltage1.out" Sum4.in as Connection69
        connect "Signal switch1.out" Sum4.in1 as Connection74
        connect "Enable disturbance.out" "Signal switch1.in2" as Connection75
        connect Disturbance.out "Signal switch1.in" as Connection76
        connect Constant1.out "Signal switch1.in1" as Connection77
        connect Vin.p_node Flyback1.a_in as Connection79
        connect Vin.n_node Flyback1.b_in as Connection80
        connect Junction7 Sum4.out as Connection82
        [
            breakpoints = 8256, 8312
        ]
        connect Vin.in Junction7 as Connection83
        connect "Input Voltage (Goto)" Junction8 as Connection84
        connect Junction8 Junction7 as Connection85
        connect "Input voltage measurement.in" Junction8 as Connection86
        connect "Referent output voltage.out" Junction5 as Connection109
        [
            breakpoints = 8296, 8592
        ]
        connect "Disturbance Compensator.out" Sum2.in1 as Connection110
        connect "Rate Limiter1.in" Junction11 as Connection123
        [
            breakpoints = 8752, 7952
        ]
        connect Junction11 Product1.out as Connection124
        [
            breakpoints = 8736, 7952
        ]
        connect Gain1.in Sum5.out as Connection126
        connect Flyback1.a_out Junction12 as Connection129
        connect Junction12 Cout.p_node as Connection130
        [
            breakpoints = 8760, 8216; 8760, 8216; 8760, 8216
        ]
        connect Vout.p_node Junction13 as Connection131
        connect Junction13 Rload.p_node as Connection132
        [
            breakpoints = 8944, 8216
        ]
        connect Junction12 Junction13 as Connection133
        connect "Low-Pass Filter1.out" Sum5.in1 as Connection137
        connect Rload.In "Rate Limiter1.out" as Connection138
        [
            breakpoints = 8840, 7952; 8800, 7952
        ]
        connect Sum5.in Junction14 as Connection139
        connect Junction14 Junction11 as Connection140
        connect "Low-Pass Filter1.in" Junction14 as Connection141
    }

    default {
        "core/Capacitor" {
            signal_access = "inherit"
            capacitance = "1e-6"
            initial_voltage = "0"
            pole_shift_ignore = "False"
            visible = "True"
        }

        "core/Constant" {
            value = "1"
            signal_type = "real"
            execution_rate = "100e-6"
            _tunable = "False"
        }

        "core/Gain" {
            gain = "1"
            multiplication = "Element-wise(K.*u)"
            _tunable = "False"
            execution_rate = "inherit"
        }

        "core/Limit" {
            upper_limit = "[\'inf\']"
            lower_limit = "[\'-inf\']"
            execution_rate = "inherit"
        }

        "core/Low-Pass Filter" {
            frequency = "500"
            init_out = "0"
            unit = "Hz"
            execution_rate = "inherit"
            _tunable = "False"
        }

        "core/PID controller" {
            controller_type = "PID"
            kp = "1"
            kp_source = "internal"
            ki = "1"
            ki_source = "internal"
            kd = "0"
            kd_source = "internal"
            filt_coef = "100"
            int_init_value = "0"
            filt_init_value = "0"
            enb_output_limit_out = "False"
            show_reset = "none"
            upper_sat_lim = "1"
            upper_sat_lim_source = "internal"
            lower_sat_lim = "-1"
            lower_sat_lim_source = "internal"
            enb_anti_windup_out = "False"
            signal_out_type = "inherit"
            _tunable = "False"
            execution_rate = "inherit"
        }

        "core/Probe" {
            signal_access = "inherit"
            addr = "0"
            override_signal_name = "False"
            signal_name = ""
            signal_type = "generic"
            streaming_en = "False"
            streaming_er_idx = "0"
            execution_rate = "inherit"
        }

        "core/Product" {
            signs = "2"
            execution_rate = "inherit"
        }

        "core/Rate Limiter" {
            rising_limit = "1"
            rising_limit_source = "internal"
            falling_limit = "-1"
            falling_limit_source = "internal"
            execution_rate = "inherit"
        }

        "core/SCADA Input" {
            signal_access = "inherit"
            addr = "0"
            format = "real"
            override_signal_name = "False"
            signal_name = ""
            signal_type = "real"
            min = "-1e6"
            max = "1e6"
            def_value = "0"
            unit = " "
            execution_rate = "100e-6"
        }

        "core/Signal switch" {
            criterion = "ctrl > threshold"
            threshold = "0.5"
            execution_rate = "inherit"
        }

        "core/Sinusoidal Source" {
            amplitude = "1"
            dc_offset = "0"
            frequency = "50"
            phase = "0"
            execution_rate = "100e-6"
            _tunable = "False"
        }

        "core/Sum" {
            signs = "2"
            execution_rate = "inherit"
        }

        "core/Flyback" {
            signal_access = "inherit"
            ctrl_src = "Digital inputs"
            op_mode = "Fixed carrier frequency"
            carrier_freq = "10000.0"
            carr_ph_offset = "0.0"
            d_time = "5e-6"
            ref_sig_min_max = "[-1.0, 1.0]"
            load_mode = "on min"
            execution_rate = "inherit"
            S1 = "1"
            S1_logic = "active high"
            show_monitoring = "False"
            n1 = "1"
            n2 = "1"
            L1 = "0.001"
            I1 = "0"
            L2 = "0.001"
            I2 = "0"
            Lm = "5"
            R1 = "0.1"
            R2 = "0.1"
            Rm = "1e4"
            pwm_enabling = "False"
            pwm_enable_di = "13"
            pwm_enable_inv = "active high"
        }

        "core/Signal Controlled Voltage Source" {
            execution_rate = "inherit"
        }

        "core/Variable Resistor" {
            inductance = "1e-3"
            initial_current = "0.0"
            hide_int_meas = "False"
        }

        "core/Voltage Measurement" {
            signal_access = "inherit"
            bw_limit = "False"
            frequency = "10e3"
            comparator_enable = "False"
            operator = "greater"
            threshold = "0"
            cmp_abs_value = "False"
            feed_forward = "false"
            sig_output = "False"
            sig_output_filt_and_full_bw = "False"
            execution_rate = "100e-6"
            addr = "0"
            nd_msr_estimation = "false"
            dev_cpl_msr = "false"
            host_device = "0"
            output_to_device = "0"
            dev_cpl_index = "0"
            dev_cpl_var_nb = "0"
            visible = "True"
            override_signal_name = "False"
            signal_name = ""
        }
    }

    CODE model_init
        # Numpy module is imported as 'np'
        # Scipy module is imported as 'sp'
        # The Schematic API is imported as 'mdl'
        # To get the model file path, use 'mdl.get_model_file_path()'
        # To print information to the console, use info()
        
        # Model Parameters
        n = 0.2
        Vin = 230 * np.sqrt(2)
        Vout = 5
        Pout_min = 7.5
        Pout_max = 100
        Pout_list = [Pout_min, Pout_max]
        PlossT_max = 0.5
        fs = 2500
        output_ripple = 0.03
        Ts = 10e-6
        
        # Calculations of parameters
        
        # Equivallent transformer resistance
        """
        Equivallent transformer resistance is calculated based on how much power
        can be dissipated on transformer during one switching frequency. Obviously,
        for different output powers, we will have different dissipation, 
        so we'll calculate the maximal allowed equivallent resistance. Then,
        we can carefully choose actual transformer windings' resistances
        based on this calculated equivallent resistance.
        """
        Req_list = []
        for i in range(len(Pout_list)):
            Pout = Pout_list[i]
            a = Vin * Vout
            b = n * Vin * Pout + Vout * (Pout + PlossT_max);
            Req_list.append((a / b)**2 * PlossT_max)
        
        Req = min(Req_list)
        
        # Actual power losses on transformer
        """
        We've calculated the worst case scenarios for both output powers and chose
        the equivallent resistance based on the worst of the worst. Now, we have to
        calculate what are actual power losses, since the power loss will not now
        be "PlossT_max" for all cases.
        """
        PlossT_list = []
        for Pout in Pout_list:
            a = Req * Vout**2;
            b = 2 * Pout * Req * Vout * (n * Vin + Vout) - Vin**2 * Vout**2
            c = Pout**2 * Req * (n**2 * Vin**2 + n * Vin * Vout + Vout**2)
            d = np.roots([a, b, c])
            PlossT_list.append(min(d))
        
        # Duty ratio
        """
        Having calculated power losses for all cases, we now calculate duty ratio.
        """
        D_list = []
        for i in range(len(Pout_list)):
            Pout = Pout_list[i]
            PlossT = PlossT_list[i]
            a = Vout * (1 + PlossT / Pout);
            b = n * Vin + a;
            D_list.append(a / b);
            
        # Choosing the windings' resistances
        """
        We can now choose an arbitrary primary or secondary winding's resistance,
        and choosing one of them will yield another. Equation for Req is given by
        
        Req = D * Rp + (1 - D) / n**2 * Rs
        
        We'll choose smartly and say that Rp = Req / D. That will make Rs = 0. 
        The user of the model is allowed to modify the resistances below, 
        as long as its' choices satisfy the equation above.
        """
        index_min_Req = Req_list.index(Req)
        Rp = Req / D_list[index_min_Req]
        info(Rp)
        Rs = 1e-9
        
        # Steady state values of magnetizing current
        ILm_list = []
        for i in range(len(Pout_list)):
            Pout = Pout_list[i]
            D = D_list[i]
            a = n * Pout
            b = (1 - D) * Vout
            ILm_list.append(a / b)
        
        # Choosing the magnetizing inductance
        """
        For this model, it is chosen for flyback to work in continuous conduction mode.
        This statement is described by the equation
        
        ILm > dILm
        
        where dILm is the current ripple. For different output powers,
        we will have different solutions for the value of magnetizing inductance,
        and the task is to find the solution which for all output powers 
        satisfies the equation above.
        """
        Lm_list = []
        for i in range(len(Pout_list)):
            Pout = Pout_list[i]
            D = D_list[i]
            ILm = ILm_list[i]
            Rload = Vout ** 2 / Pout
            a = (1 - D)**2 * D * Rload * Vin
            b = 2 * fs * ILm * ((1 - D)**2 * Rload + n**2 * Req)
            Lm_list.append(a / b)
        
        Lm = max(Lm_list) + 1e-2
        info(Lm)
        
        # Choosing the output capacitance
        Cout_list = []
        for i in range(len(Pout_list)):
            Pout = Pout_list[i]
            D = D_list[i]
            Rload = Vout ** 2 / Pout
            a = n * D**2 * (1 - D) * Vin
            b = 2 * output_ripple * fs * Vout * ((1 - D)**2 * Rload + n**2 * Req)
            Cout_list.append(a / b)
        
        Cout = max(Cout_list) + 1e-2
        info(Cout)
        
        dist_comp_gain = 2.0392e-4
    ENDCODE
}
