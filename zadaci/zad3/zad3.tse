version = 4.2

//
// Saved by sw version: 2024.1
//

model "zad3" {
    configuration {
        hil_device = "HIL606"
        hil_configuration_id = 2
        simulation_method = exact
        simulation_time_step = 1e-6
        simulation_discret_scaling = 1.0
        dsp_timer_periods = 100e-6, 50e-3
        ss_calc_method = "systematic elimination"
        enb_pole_shift = True
        enb_gds_oversampling = True
        show_modes = False
        device_ao_limit_enable = False
        reset_analog_outputs_on_sim_stop = True
        reset_analog_outputs_on_sim_stop_mode = Offset values
        reset_digital_outputs_on_sim_stop = True
        vhil_adio_loopback = False
        cpl_stb = False
        enb_dep_sw_detect = False
        code_section = "internal memory"
        data_section = "internal memory"
        sys_sp_rate_1 = 0.0001
        sys_sp_rate_2 = 0.05
        sys_real_type_precision = "default"
        user_real_type_precision = "default"
        sys_cpu_optimization = "high"
        user_cpu_optimization = "high"
        user_cpu_part_option = "default"
        matrix_based_reduction = True
        cpl_dynamics_analysis = False
        export_ss_to_pickle = False
        ground_scope_core = False
        dss_num_tol = 1e-15
        cce_platform = "generic"
        cce_use_relative_names = False
        cce_type_mapping_real = "double"
        cce_type_mapping_uint = "unsigned int"
        cce_type_mapping_int = "int"
        cce_platform = "generic"
        cce_use_relative_names = False
        cce_type_mapping_real = "double"
        cce_type_mapping_uint = "unsigned int"
        cce_type_mapping_int = "int"
        cce_directory = ""
        cce_custom_type_int = ""
        cce_custom_type_uint = ""
        cce_custom_type_real = ""
        tunable_params = "component defined"
        sp_compiler_type = "C compiler"
        sig_stim = "off"
        export_resource_list = ""
        export_dependency_list = ""
        excluded_resource_list = ""
        export_out_file = ""
        export_lock_top_level = True
        export_encrypt_library = True
        export_encrypt_resources = True
        dae_solver = "BDF"
        max_sim_step = 1e-4
        simulation_time = 1.0
        abs_tol = 1e-3
        rel_tol = 1e-3
        init_sim_step = 1e-6
        r_on_sw = 1e-3
        v_on_diode = 0.2
        data_sampling_rate = 0
        feedthrough_validation_error_level = error
    }

    component Subsystem Root {
        component "core/Buck - Boost" Buck-Boost {
            carrier_freq = "fsw"
            ctrl_src = "Model"
            d_time = "0"
            ref_sig_min_max = "[0, 1]"
            signal_access = "Inherit"
        }
        [
            position = 8504, 8224
            size = 255, 127
        ]

        component "core/Voltage Source" Vin {
            init_const_value = "Vin"
        }
        [
            position = 8216, 8408
            rotation = right
        ]

        component "core/Inductor" L {
            inductance = "L"
            signal_access = "Inherit"
        }
        [
            position = 8504, 8408
            rotation = right
        ]

        component "core/Capacitor" Cout {
            capacitance = "Cout"
            signal_access = "Inherit"
        }
        [
            position = 8752, 8408
            rotation = right
        ]

        component "core/Resistor" RL {
            resistance = "RL"
        }
        [
            position = 8504, 8504
            rotation = right
        ]

        component "core/Voltage Measurement" Vout {
            execution_rate = "Ts"
            sig_output = "True"
            signal_access = "Inherit"
        }
        [
            position = 9024, 8408
            rotation = left
            size = 64, 32
        ]

        component Subsystem Compensator {
            layout = dynamic
            component "core/SR Flip Flop" "SR Flip Flop1" {
            }
            [
                position = 8232, 8056
            ]

            component "core/Square Wave Source" fsw {
                _tunable = "True"
                duty_cycle = "0.001"
                execution_rate = "Ts"
                frequency = "fsw"
                signal_type = "int"
            }
            [
                position = 8056, 7960
            ]

            component "core/Comparator" Comparator1 {
            }
            [
                position = 8040, 8072
                hide_name = True
            ]

            component "core/Probe" Duty {
            }
            [
                position = 8416, 7960
            ]

            component "core/SCADA Input" IPeak {
                execution_rate = "Ts"
                max = "20"
                min = "0"
                signal_access = "Inherit"
                unit = ""
            }
            [
                position = 7696, 8072
            ]

            component "core/Probe" Imax {
            }
            [
                position = 7992, 8176
            ]

            component "core/Triangular Wave Source" "Slope compensation" {
                duty_cycle = "0.99"
                execution_rate = "Ts"
                frequency = "fsw"
                max_val = "20 / L * (0.99 * 1 / fsw)"
                min_val = "0"
            }
            [
                position = 7696, 8160
            ]

            component "core/Sum" Sum1 {
                signs = "+-"
            }
            [
                position = 7832, 8080
                hide_name = True
            ]

            component "core/Probe" Probe1 {
            }
            [
                position = 7856, 8168
            ]

            port Isw {
                position = left:1
                kind = sp
                direction =  out
                sp_type {
                    default = auto
                    readonly = True
                }
            }
            [
                position = 7696, 7952
            ]

            port Control {
                position = right:1
                kind = sp
                direction =  in
                sp_type {
                    default = inherit
                    readonly = True
                }
            }
            [
                position = 8416, 8040
            ]

            junction Junction4 sp
            [
                position = 8384, 8040
            ]

            junction Junction5 sp
            [
                position = 7952, 8080
            ]

            junction Junction6 sp
            [
                position = 7792, 8160
            ]

            connect Comparator1.in1 Isw as Connection129
            [
                breakpoints = 8008, 8016; 7728, 8016
            ]
            connect Duty.in Junction4 as Connection176
            connect Junction4 Control as Connection177
            [
                breakpoints = 8384, 8040; 8384, 8040; 8384, 8040; 8384, 8040
            ]
            connect "SR Flip Flop1.out" Junction4 as Connection178
            connect fsw.out "SR Flip Flop1.s_in" as Connection181
            connect Comparator1.out "SR Flip Flop1.r_in" as Connection182
            connect Imax.in Junction5 as Connection184
            connect Junction5 Comparator1.in2 as Connection185
            [
                breakpoints = 7952, 8080; 7976, 8080; 7976, 8080; 7976, 8080; 7976, 8080; 7976, 8080
            ]
            connect Sum1.out Junction5 as Connection186
            connect IPeak.out Sum1.in as Connection187
            connect "Slope compensation.out" Junction6 as Connection189
            connect Junction6 Sum1.in1 as Connection190
            connect Probe1.in Junction6 as Connection191
        }
        [
            position = 9096, 8048
            size = 88, 64
        ]

        component "core/Current Measurement" Isw {
            execution_rate = "Ts"
            sig_output = "True"
            signal_access = "Inherit"
        }
        [
            position = 8296, 8224
            size = 64, 32
        ]

        component "core/Current Measurement" Iout {
        }
        [
            position = 8888, 8336
            rotation = left
            size = 64, 32
        ]

        component "core/Variable Resistor" RLoad {
            inductance = "1e-5"
        }
        [
            position = 8888, 8464
            rotation = left
            size = 64, 48
        ]

        component "core/SCADA Input" "Output power" {
            unit = ""
        }
        [
            position = 8368, 8784
        ]

        component "core/SCADA Input" "Output voltage" {
            unit = ""
        }
        [
            position = 8368, 8696
        ]

        component Subsystem "Resistance calculation" {
            layout = dynamic
            component "core/Product" Product1 {
            }
            [
                position = 8112, 8096
                hide_name = True
            ]

            component "core/Product" Product2 {
                signs = "*/"
            }
            [
                position = 8208, 8168
                hide_name = True
            ]

            port Power {
                position = left:2
                kind = sp
                direction =  out
                sp_type {
                    default = auto
                    readonly = True
                }
            }
            [
                position = 8000, 8176
            ]

            port Resistance {
                position = right:1
                kind = sp
                direction =  in
                sp_type {
                    default = inherit
                    readonly = True
                }
            }
            [
                position = 8352, 8168
            ]

            port Voltage {
                position = left:1
                kind = sp
                direction =  out
                sp_type {
                    default = auto
                    readonly = True
                }
            }
            [
                position = 8000, 8088
            ]

            junction Junction10 sp
            [
                position = 8048, 8088
            ]

            connect Product2.out Resistance as Connection101
            connect Product2.in1 Power as Connection100
            connect Junction10 Voltage as Connection102
            connect Junction10 Product1.in as Connection96
            connect Product1.in1 Junction10 as Connection97
            connect Product1.out Product2.in as Connection99
        }
        [
            position = 8592, 8736
            size = 160, 56
        ]

        tag Goto1 {
            value = "Control"
            scope = local
            kind = sp
            direction = in
        }
        [
            position = 9232, 8048
            size = 60, 20
        ]

        tag From1 {
            value = "Control"
            scope = local
            kind = sp
            direction = out
        }
        [
            position = 8368, 8080
            size = 60, 20
        ]

        tag Goto2 {
            value = "tag1"
            scope = global
            kind = sp
            direction = in
        }
        [
            position = 8576, 8648
            size = 60, 20
        ]

        tag Goto3 {
            value = "tag2"
            scope = global
            kind = sp
            direction = in
        }
        [
            position = 8560, 8840
            size = 60, 20
        ]

        junction Junction2 pe
        [
            position = 8752, 8224
        ]

        junction Junction5 pe
        [
            position = 8504, 8576
        ]

        junction Junction6 pe
        [
            position = 8752, 8576
        ]

        junction Junction8 pe
        [
            position = 8888, 8224
        ]

        junction Junction9 pe
        [
            position = 8888, 8576
        ]

        junction Junction10 sp
        [
            position = 8456, 8696
        ]

        junction Junction11 sp
        [
            position = 8448, 8784
        ]

        connect L.n_node RL.p_node as Connection4
        connect Buck-Boost.neg_out Junction2 as Connection19
        connect Junction2 Cout.p_node as Connection20
        [
            breakpoints = 8752, 8224
        ]
        connect Compensator.Control Goto1 as Connection59
        connect From1 Buck-Boost.s_ctrl as Connection60
        connect Vin.n_node Junction5 as Connection65
        connect Junction5 RL.n_node as Connection66
        connect Cout.n_node Junction6 as Connection68
        connect Junction6 Junction5 as Connection69
        connect Vout.n_node Junction8 as Connection81
        [
            breakpoints = 8904, 8224
        ]
        connect Junction8 Junction2 as Connection82
        [
            breakpoints = 8888, 8224; 8888, 8224; 8752, 8224
        ]
        connect Iout.n_node Junction8 as Connection83
        connect RLoad.n_node Iout.p_node as Connection90
        connect Junction6 Junction9 as Connection91
        [
            breakpoints = 8752, 8576
        ]
        connect Junction9 Vout.p_node as Connection92
        [
            breakpoints = 8888, 8576
        ]
        connect RLoad.p_node Junction9 as Connection93
        connect RLoad.In "Resistance calculation.Resistance" as Connection95
        [
            breakpoints = 8728, 8464; 8728, 8736
        ]
        connect "Output voltage.out" Junction10 as Connection97
        connect Junction10 "Resistance calculation.Voltage" as Connection98
        connect Goto2 Junction10 as Connection99
        connect "Output power.out" Junction11 as Connection100
        connect Junction11 "Resistance calculation.Power" as Connection101
        connect Goto3 Junction11 as Connection102
        connect Isw.n_node Buck-Boost.pos_out as Connection103
        connect Isw.p_node Vin.p_node as Connection104
        connect Buck-Boost.a_in L.p_node as Connection105
        connect Isw.out Compensator.Isw as Connection106
        [
            breakpoints = 8296, 8128; 9016, 8120; 9016, 8048
        ]
    }

    default {
        "core/Capacitor" {
            signal_access = "inherit"
            capacitance = "1e-6"
            initial_voltage = "0"
            pole_shift_ignore = "False"
            visible = "True"
        }

        "core/Comparator" {
            execution_rate = "inherit"
        }

        "core/Inductor" {
            signal_access = "inherit"
            inductance = "1e-3"
            initial_current = "0.0"
            pole_shift_ignore = "False"
            visible = "True"
        }

        "core/Probe" {
            signal_access = "inherit"
            addr = "0"
            override_signal_name = "False"
            signal_name = ""
            signal_type = "generic"
            streaming_en = "False"
            streaming_er_idx = "0"
            execution_rate = "inherit"
        }

        "core/Product" {
            signs = "2"
            execution_rate = "inherit"
        }

        "core/Resistor" {
            resistance = "1"
            param_set = ""
        }

        "core/SCADA Input" {
            signal_access = "inherit"
            addr = "0"
            format = "real"
            override_signal_name = "False"
            signal_name = ""
            signal_type = "real"
            min = "-1e6"
            max = "1e6"
            def_value = "0"
            unit = " "
            execution_rate = "100e-6"
        }

        "core/SR Flip Flop" {
            init_value = "0"
            execution_rate = "inherit"
        }

        "core/Square Wave Source" {
            hs_output = "1"
            ls_output = "0"
            frequency = "50"
            duty_cycle = "0.5"
            phase = "0"
            signal_type = "real"
            execution_rate = "100e-6"
            _tunable = "False"
        }

        "core/Sum" {
            signs = "2"
            execution_rate = "inherit"
        }

        "core/Triangular Wave Source" {
            min_val = "-0.5"
            max_val = "0.5"
            frequency = "50"
            duty_cycle = "0.5"
            phase = "0"
            execution_rate = "100e-6"
            _tunable = "False"
        }

        "core/Voltage Source" {
            sig_input = "False"
            type = "signal generator"
            param_set = "1phase"
            parent_label = ""
            addr = "0"
            spc_nb = "0"
            execution_rate = "100e-6"
            cpd_visible = "True"
            enable_snb = "False"
            snb_type = "R2"
            R2 = "0.0"
            L1 = "0.1"
            override_signal_name = "False"
            signal_name = ""
            init_source_nature = "Constant"
            init_const_value = "0.0"
            init_rms_value = "0.0"
            init_frequency = "50.0"
            init_phase = "0.0"
        }

        "core/Buck - Boost" {
            signal_access = "inherit"
            ctrl_src = "Digital inputs"
            op_mode = "Fixed carrier frequency"
            carrier_freq = "10000.0"
            carr_ph_offset = "0.0"
            d_time = "5e-6"
            ref_sig_min_max = "[-1.0, 1.0]"
            load_mode = "on min"
            execution_rate = "inherit"
            S1 = "1"
            S1_logic = "active high"
            pwm_enabling = "False"
            pwm_enable_di = "13"
            pwm_enable_inv = "active high"
            show_monitoring = "False"
        }

        "core/Current Measurement" {
            signal_access = "inherit"
            bw_limit = "False"
            frequency = "10e3"
            comparator_enable = "False"
            operator = "greater"
            threshold = "0"
            cmp_abs_value = "False"
            feed_forward = "false"
            sig_output = "False"
            sig_output_filt_and_full_bw = "False"
            execution_rate = "100e-6"
            addr = "0"
            nd_msr_estimation = "false"
            dev_cpl_msr = "false"
            host_device = "0"
            output_to_device = "0"
            dev_cpl_index = "0"
            dev_cpl_var_nb = "0"
            visible = "True"
            override_signal_name = "False"
            signal_name = ""
        }

        "core/Variable Resistor" {
            inductance = "1e-3"
            initial_current = "0.0"
            hide_int_meas = "False"
        }

        "core/Voltage Measurement" {
            signal_access = "inherit"
            bw_limit = "False"
            frequency = "10e3"
            comparator_enable = "False"
            operator = "greater"
            threshold = "0"
            cmp_abs_value = "False"
            feed_forward = "false"
            sig_output = "False"
            sig_output_filt_and_full_bw = "False"
            execution_rate = "100e-6"
            addr = "0"
            nd_msr_estimation = "false"
            dev_cpl_msr = "false"
            host_device = "0"
            output_to_device = "0"
            dev_cpl_index = "0"
            dev_cpl_var_nb = "0"
            visible = "True"
            override_signal_name = "False"
            signal_name = ""
        }
    }

    CODE model_init
        # Numpy module is imported as 'np'
        # Scipy module is imported as 'sp'
        # The Schematic API is imported as 'mdl'
        # To get the model file path, use 'mdl.get_model_file_path()'
        # To print information to the console, use info()
        
        # Plant criteria
        Vin = 12
        Vout_min = 5
        Vout_max = 20
        Vout_list = [Vout_min, Vout_max]
        
        Pout_min = 50
        Pout_max = 50
        Pout_list = [Pout_min, Pout_max]
        
        fsw = 10e3
        eff = 0.95
        
        Vout_ripple_max = 0.05
        IL_ripple_max = 0.2
        
        Ts = 2e-6
        
        # Output current
        """
        Add comment here
        """
        Iout_list = {}
        for Pout in Pout_list:
            Iout_list[Pout] = {}
            for Vout in Vout_list:
                Iout_list[Pout][Vout] = Pout / Vout
        
        # Allowed RL
        """
        Add comment here
        """
        RL_list = {}
        for Pout in Pout_list:
            RL_list[Pout] = {}
            for Vout in Vout_list:
                Iout = Iout_list[Pout][Vout]
                a = eff * (1 - eff) * Vout * Vin**2
                b = (eff * Vin + Vout) ** 2 * Iout
                RL_list[Pout][Vout] = a / b
        
        RL = min(RL_list[Pout][Vout] for Pout in Pout_list for Vout in Vout_list)
        
        # Duty ratio
        """
        Add comment here
        """
        D0_list = {}
        for Pout in Pout_list:
            D0_list[Pout] = {}
            for Vout in Vout_list:
                Iout = Iout_list[Pout][Vout]
                a = Vin + Vout
                b = -Vin - 2 * Vout
                c = Iout * RL + Vout
                D0_list[Pout][Vout] = np.roots([a, b, c])[1]
        
        # IL calculation
        """
        Add comment here
        """
        IL_list = {}
        for Pout in Pout_list:
            IL_list[Pout] = {}
            for Vout in Vout_list:
                Iout = Iout_list[Pout][Vout]
                D0 = D0_list[Pout][Vout]
                IL_list[Pout][Vout] = Iout / (1 - D0)
        
        # Inductance calculation
        """
        Add comment here
        """
        L_list = {}
        for Pout in Pout_list:
            L_list[Pout] = {}
            for Vout in Vout_list:
                Iout = Iout_list[Pout][Vout]
                D0 = D0_list[Pout][Vout]
                a = D0 * ((1 - D0) * Vin - RL * Iout)
                b = 2 * IL_ripple_max * fsw * Iout
                L_list[Pout][Vout] = a / b
        
        L = min(L_list[Pout][Vout] for Pout in Pout_list for Vout in Vout_list) + 1e-3
        
        # Capacitance calculation
        """
        Add comment here
        """
        Cout_list = {}
        for Pout in Pout_list:
            Cout_list[Pout] = {}
            for Vout in Vout_list:
                Iout = Iout_list[Pout][Vout]
                D0 = D0_list[Pout][Vout]
                a = D0 * Iout
                b = 2 * Vout_ripple_max * fsw * Vout
                Cout_list[Pout][Vout] = a / b
        
        Cout = min(Cout_list[Pout][Vout] for Pout in Pout_list for Vout in Vout_list) + 1e-3
    ENDCODE
}
