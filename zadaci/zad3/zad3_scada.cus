<ui_settings>
    <version>2.8</version>
    <model_locked>True</model_locked>
    <canvas_bg_color>#ffffff</canvas_bg_color>
    <initialization_code><![CDATA[# NOTE: Variables and functions defined here will be
# available for use in all Macro and Expression scripts.
# NOTE: This code is always executed prior to simulation start.

# The variable 'SETTINGS_DIR' holds the directory where the loaded Panel .cus file is located.
# Also you can call the 'get_settings_dir_path()' function in any
# Macro and Expression script to get the same directory.
SETTINGS_DIR = get_settings_dir_path()

# The 'add_to_python_path(folder)' function can be used to add a custom folder
# with Python files and packages to the PYTHONPATH. After a folder is added, all Python
# files and Python packages from it can be imported into the SCADA Namespace.

# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# Numpy module is imported as 'np'
# Scipy module is imported as 'sp'
# Schematic Editor model namespace is imported as 'scm'
# Function for printing to the HIL SCADA Message log is imported as 'printf'.

import control as ct

# Plant criteria
Vin = 12                            # Input voltage
Vout_min = 5                        # Minimal output voltage
Vout_max = 20                       # Maximum output voltage
Vout_list = [Vout_min, Vout_max]    # List of min-max voltages

Rload = 8                           # Load resistance
Vout_ripple_max = 0.05              # Allowed output voltage ripple
IL_ripple_max = 0.2                 # Allowed inductor current ripple

fsw = 10e3                          # Switching frequency
eff = 0.95                          # Worst case efficiency of the converter

Ts = 5e-6                           # Execution rate of signal processing components

# Allowed RL
"""
Since we want a degree of efficiency of 'eff', we'll calculate the allowed
parasitic resistance for to achieve it.
"""
RL_list = {}
for Vout in Vout_list:
    a = eff * (1 - eff) * Vin**2 * Rload
    b = (eff * Vin + Vout) ** 2
    RL_list[Vout] = a / b

RL = min(RL_list[Vout] for Vout in Vout_list)

# Duty ratio
"""
Now, we can calculate the duty ratio needed to achieve
given output voltages.
"""
D0_list = {}
for Vout in Vout_list:
    a = -Rload * (Vin + Vout)
    b = -Rload * (Vin + 2 * Vout)
    c = -Vout * (Rload + RL)
    D0_list[Vout] = np.abs(np.roots([a, b, c])[1])

# IL calculation
"""
For the inductor's inductance, we'll firstly need calculate the
inductor's current.
"""
IL_list = {}
for Vout in Vout_list:
    D0 = D0_list[Vout]
    a = D0 * Vin
    b = (1 - D0) ** 2 * Rload + RL
    IL_list[Vout] = a / b

# Inductance calculation
"""
Now, to hold the inductor's current in margins of the given ripple, 
we'll calculate the inductance needed.
"""
L_list = {}
for Vout in Vout_list:
    D0 = D0_list[Vout]
    a = (1 - D0) * ((1 - D0) * Rload + RL)
    b = 2 * IL_ripple_max * fsw
    L_list[Vout] = a / b

L = max(L_list[Vout] for Vout in Vout_list) + 1e-3

# Capacitance calculation
"""
Now, to hold the output voltage in margins of the given ripple, 
we'll calculate the capacitance needed.
"""
Cout_list = {}
for Vout in Vout_list:
    D0 = D0_list[Vout]
    a = D0
    b = 2 * Vout_ripple_max * fsw * Rload
    Cout_list[Vout] = a / b

Cout = max(Cout_list[Vout] for Vout in Vout_list) + 1e-3

# Bleeder resistance
"""
In order for buck-boost converter to work in continuous conduction mode,
it needs some minimal load on itself.
"""
Rb_list = {}
for Vout in Vout_list:
    D0 = D0_list[Vout]
    Rb_list[Vout] = 1 / (1 - D0) * (2 * fsw * L / (1 - D0) - RL);

Rb = min(Rb_list[Vout] for Vout in Vout_list)

def get_transfer_function(R, Vout, Vin, RL, L, Cout):
    """
    Returns the transfer functions in this order:
        GVI - from input voltage to inductor current
        GVV - from input voltage to output voltage
        GDI - from duty ratio to inductor current
        GDV - from duty ratio to output voltage
    """
    a = -R * (Vin + Vout);
    b = R * (-Vin - 2 * Vout);
    c = -Vout * (R + RL);
    D0 = np.abs(np.roots([a, b, c])[1])
    
    A11 = -RL / L
    A12 = (1 - D0) / L
    A21 = -(1 - D0) / Cout
    A22 = -1 / (R * Cout)
    
    A = [[A11, A12], [A21, A22]]
    
    B11 = D0 / L
    B12 = ((1 - D0) * R + RL) * Vin / (L * ((1 - D0)**2 * R + RL))
    B21 = 0
    B22 = D0 * Vin / (Cout * ((1 - D0)**2 * R + RL))
    
    B = [[B11, B12], [B21, B22]]
    
    B1 = [[B11], [B21]]
    B2 = [[B12], [B22]]
    
    C1 = [1, 0]
    C2 = [0, -1]
    
    D1 = [[0]]
    D2 = [[0]]
    
    GVI = ct.ss2tf(ct.ss(A, B1, C1, D1))
    GVV = ct.ss2tf(ct.ss(A, B1, C2, D1))
    GDI = ct.ss2tf(ct.ss(A, B2, C1, D2))
    GDV = ct.ss2tf(ct.ss(A, B2, C2, D2))
    
    Gplant = ct.minreal(GDV / GDI)                
    HVI = ct.minreal(Gplant / (GVV - GVI * GDV / GDI))
    input_voltage_compensator_dcgain = ct.dcgain(HVI)
    
    return GVI, GVV, GDI, GDV
    
def get_compensating_gain(R, Vout, Vin, RL, L, Cout):
    """
    Calculates the needed compensator gain for input voltage variations. 
    """
    GVI, GVV, GDI, GDV = get_transfer_function(R, Vout, Vin, RL, L, Cout)
    Gplant = ct.minreal(GDV / GDI)
    HVI = (GVV * GDI - GDV * GVI) / GDV
    
    return ct.dcgain(HVI)
]]></initialization_code>
    <components>
        <component_data>
                <id>eac0c6462c8711ef9d81f3447f08d04b</id>
                <name><![CDATA[Control panel]]></name>
                <type>Group</type>
                <description><![CDATA[]]></description>
                <components_ids><![CDATA[['fee78b932c8711ef8cf7f3447f08d04b', '118d19812c8811ef98d9f3447f08d04b', '1f1dba232c8811efb5eef3447f08d04b', '2e78e23e2c8811ef9f13f3447f08d04b', '6014d05a30cb11ef9e8bec0fddbd2a74', '4c17459130cc11ef977fec0fddbd2a74', 'e6d160ad30cc11efb04cec0fddbd2a74', 'ddee8c03323011ef9b05141333de5773', 'baf207ad32c411ef8f2bdbfccc9e91fd']]]></components_ids>
                <canvas_bg_color>#ffffff</canvas_bg_color>
                <initialization_code><![CDATA[# NOTE: Variables and functions defined here will be available for use in
# all Macro, Expression and handlers codes of components owned by this widget.
# This code is always executed prior simulation start. In case this is a
# Library Widget, this code is also executed on drag and drop, Panel load
# and widget paste.
#
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

]]></initialization_code>
                <widget_settings>
                    <x>88</x>
                    <y>24</y>
                    <width>1000</width>
                    <height>576</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <collapsed>False</collapsed>
                    <hierarchy_position>1</hierarchy_position>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
                
                <linked_model_components_settings>
                    </linked_model_components_settings>
            </component_data>
        <component_data>
                <id>fee78b932c8711ef8cf7f3447f08d04b</id>
                <name><![CDATA[Input voltage]]></name>
                <type>Gauge</type>
                <description><![CDATA[]]></description>
                <data_type>Analog signal</data_type>
                <code><![CDATA[# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API

# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# mandatory variable used for storing value that will be displayed
displayValue = 0.0

]]></code>
                <signal_name><![CDATA[Va1]]></signal_name>
                <unit><![CDATA[V]]></unit>
                <automatic_unit>True</automatic_unit>
                <updateRate>250</updateRate>
                <decimals>2</decimals>
                <scaling_factor>1.0</scaling_factor>
                <widget_settings>
                    <x>80</x>
                    <y>32</y>
                    <width>320</width>
                    <height>176</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
                <advance_widget_settings>
                    <color_range>False</color_range>
                    <min>0.0</min>
                    <max>20.0</max>
                    <warning_range>(0, 0, 0, 0)</warning_range>
                    <critical_range>(0, 0, 0, 0)</critical_range>
                </advance_widget_settings>
            </component_data>
        <component_data>
                <id>118d19812c8811ef98d9f3447f08d04b</id>
                <name><![CDATA[Output voltage]]></name>
                <type>Gauge</type>
                <description><![CDATA[]]></description>
                <data_type>Analog signal</data_type>
                <code><![CDATA[# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API

# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# mandatory variable used for storing value that will be displayed
displayValue = 0.0

]]></code>
                <signal_name><![CDATA[Vout]]></signal_name>
                <unit><![CDATA[V]]></unit>
                <automatic_unit>True</automatic_unit>
                <updateRate>250</updateRate>
                <decimals>2</decimals>
                <scaling_factor>1.0</scaling_factor>
                <widget_settings>
                    <x>584</x>
                    <y>32</y>
                    <width>320</width>
                    <height>176</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
                <advance_widget_settings>
                    <color_range>False</color_range>
                    <min>0.0</min>
                    <max>30.0</max>
                    <warning_range>(0, 0, 0, 0)</warning_range>
                    <critical_range>(0, 0, 0, 0)</critical_range>
                </advance_widget_settings>
            </component_data>
        <component_data>
                <id>1f1dba232c8811efb5eef3447f08d04b</id>
                <name><![CDATA[Reference output voltage]]></name>
                <type>SliderMacro</type>
                <description><![CDATA[]]></description>
                <on_use_code active="True"><![CDATA[# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.
# NOTE: entered value is available through variable 'inputValue'

hil.model_write('Output voltage', inputValue)
hil.model_write('Controller.Slope compensation.max_val', inputValue / L * (0.9999 / fsw))

R = panel.get_property_value(panel.get_widget_by_fqn('Control panel.Load resistance'), api_const.PROP_WIDGET_VALUE)

compensation_gain = get_compensating_gain(R, inputValue, Vin, RL, L, Cout)
hil.model_write('Controller.Gain.gain', compensation_gain)]]></on_use_code>
                <on_start_code active="True"><![CDATA[# NOTE: The code specified in this handler will be executed on simulation start.
# NOTE: Variables specified here will be available in other handlers.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_start_code>
                <on_stop_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed after simulation is stopped.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_stop_code>
                <on_timer_code active="True"><![CDATA[# NOTE: The code specified in this handler will be executed periodically each 1000ms.
# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change the widget value by setting this variable.
# NOTE: If you do not specify a 'widgetValue' variable or assign 'None' to it,
# the widget value will not be changed.
widgetValue = hil.model_read('Output voltage')
]]></on_timer_code>
                <on_start_code_source><![CDATA[Macro code]]></on_start_code_source>
                <inputValue><![CDATA[20.0]]></inputValue>
                <min>5.0</min>
                <max>20.0</max>
                <step>1.0</step>
                <widget_settings>
                    <x>584</x>
                    <y>216</y>
                    <width>328</width>
                    <height>48</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        <component_data>
                <id>2e78e23e2c8811ef9f13f3447f08d04b</id>
                <name><![CDATA[Disturbance]]></name>
                <type>ComboBoxMacro</type>
                <description><![CDATA[]]></description>
                <on_use_code active="True"><![CDATA[# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.
# NOTE: entered value is available through variable 'inputValue'

Vin = 12

if inputValue == 'No disturbance':
    hil.set_scada_input_value('Enable disturbance', 0)
    
elif inputValue == '0.1Hz disturbance':
    hil.model_write('Disturbance.amplitude', 0.2 * Vin)
    hil.model_write('Disturbance.frequency', 0.1)
    hil.set_scada_input_value('Enable disturbance', 1)
    
else:
    hil.model_write('Disturbance.amplitude', 0.2 * Vin)
    hil.model_write('Disturbance.frequency', 10)
    hil.set_scada_input_value('Enable disturbance', 1)

]]></on_use_code>
                <on_start_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed on simulation start.
# NOTE: Variables specified here will be available in other handlers.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_start_code>
                <on_stop_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed after simulation is stopped.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_stop_code>
                <on_timer_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed periodically each 1000ms.
# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change the widget value by setting this variable.
# NOTE: If you do not specify a 'widgetValue' variable or assign 'None' to it,
# the widget value will not be changed.
widgetValue = None
]]></on_timer_code>
                <on_start_code_source><![CDATA[Custom code]]></on_start_code_source>
                <inputValue><![CDATA[No disturbance]]></inputValue>
                <availableValues><![CDATA[['No disturbance', '0.1Hz disturbance', '10Hz disturbance']]]></availableValues>
                <unit><![CDATA[]]></unit>
                <widget_settings>
                    <x>80</x>
                    <y>224</y>
                    <width>320</width>
                    <height>40</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        <component_data>
                <id>6014d05a30cb11ef9e8bec0fddbd2a74</id>
                <name><![CDATA[Output power]]></name>
                <type>Gauge</type>
                <description><![CDATA[]]></description>
                <data_type>Expression</data_type>
                <code><![CDATA[# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API

# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

Vout = hil.model_read('Vout')
Iout = hil.model_read('Iout')

displayValue = Iout * Vout
]]></code>
                <signal_name><![CDATA[Va1]]></signal_name>
                <unit><![CDATA[W]]></unit>
                <automatic_unit>True</automatic_unit>
                <updateRate>250</updateRate>
                <decimals>2</decimals>
                <scaling_factor>1.0</scaling_factor>
                <widget_settings>
                    <x>80</x>
                    <y>312</y>
                    <width>320</width>
                    <height>176</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
                <advance_widget_settings>
                    <color_range>False</color_range>
                    <min>0.0</min>
                    <max>100.0</max>
                    <warning_range>(0, 0, 0, 0)</warning_range>
                    <critical_range>(0, 0, 0, 0)</critical_range>
                </advance_widget_settings>
            </component_data>
        <component_data>
                <id>4c17459130cc11ef977fec0fddbd2a74</id>
                <name><![CDATA[Control mode]]></name>
                <type>ComboBoxMacro</type>
                <description><![CDATA[]]></description>
                <on_use_code active="True"><![CDATA[# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.
# NOTE: entered value is available through variable 'inputValue'

if inputValue == 'Open loop control':
    hil.set_scada_input_value('Controller.Control mode', 1)
elif inputValue == 'Voltage mode control':
    hil.set_scada_input_value('Controller.Control mode', 2)
else:
    hil.set_scada_input_value('Controller.Control mode', 3)

]]></on_use_code>
                <on_start_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed on simulation start.
# NOTE: Variables specified here will be available in other handlers.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_start_code>
                <on_stop_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed after simulation is stopped.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_stop_code>
                <on_timer_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed periodically each 1000ms.
# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change the widget value by setting this variable.
# NOTE: If you do not specify a 'widgetValue' variable or assign 'None' to it,
# the widget value will not be changed.
widgetValue = None
]]></on_timer_code>
                <on_start_code_source><![CDATA[Custom code]]></on_start_code_source>
                <inputValue><![CDATA[Current mode control]]></inputValue>
                <availableValues><![CDATA[['Open loop control', 'Voltage mode control', 'Current mode control']]]></availableValues>
                <unit><![CDATA[]]></unit>
                <widget_settings>
                    <x>584</x>
                    <y>400</y>
                    <width>328</width>
                    <height>32</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        <component_data>
                <id>e6d160ad30cc11efb04cec0fddbd2a74</id>
                <name><![CDATA[Turn on load]]></name>
                <type>CheckBoxMacro</type>
                <description><![CDATA[]]></description>
                <on_use_code active="True"><![CDATA[# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.
# NOTE: entered value is available through variable 'inputValue'

if inputValue:
    hil.set_scada_input_value('Turn on load', 1)
else:
    hil.set_scada_input_value('Turn on load', 0)

]]></on_use_code>
                <on_start_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed on simulation start.
# NOTE: Variables specified here will be available in other handlers.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_start_code>
                <on_stop_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed after simulation is stopped.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_stop_code>
                <on_timer_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed periodically each 1000ms.
# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change the widget value by setting this variable.
# NOTE: If you do not specify a 'widgetValue' variable or assign 'None' to it,
# the widget value will not be changed.
widgetValue = None
]]></on_timer_code>
                <on_start_code_source><![CDATA[Custom code]]></on_start_code_source>
                <inputValue><![CDATA[True]]></inputValue>
                <widget_settings>
                    <x>680</x>
                    <y>440</y>
                    <width>120</width>
                    <height>32</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        <component_data>
                <id>ddee8c03323011ef9b05141333de5773</id>
                <name><![CDATA[Open loop duty ratio]]></name>
                <type>SliderMacro</type>
                <description><![CDATA[]]></description>
                <on_use_code active="True"><![CDATA[# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.
# NOTE: entered value is available through variable 'inputValue'

hil.model_write('Controller.Open loop duty ratio.duty_cycle', inputValue)]]></on_use_code>
                <on_start_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed on simulation start.
# NOTE: Variables specified here will be available in other handlers.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_start_code>
                <on_stop_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed after simulation is stopped.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_stop_code>
                <on_timer_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed periodically each 1000ms.
# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change the widget value by setting this variable.
# NOTE: If you do not specify a 'widgetValue' variable or assign 'None' to it,
# the widget value will not be changed.
widgetValue = None
]]></on_timer_code>
                <on_start_code_source><![CDATA[Custom code]]></on_start_code_source>
                <inputValue><![CDATA[0.3]]></inputValue>
                <min>0.0</min>
                <max>100.0</max>
                <step>1.0</step>
                <widget_settings>
                    <x>584</x>
                    <y>336</y>
                    <width>328</width>
                    <height>48</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        <component_data>
                <id>8a3b77c8230a11efb2c3f3447f08d04b</id>
                <name><![CDATA[Capture/Scope]]></name>
                <type>Capture/Scope</type>
                <description><![CDATA[]]></description>
                <working_mode>windowed</working_mode>
                <widget_settings>
                    <x>1144</x>
                    <y>256</y>
                    <width>120</width>
                    <height>120</height>
                    <hierarchy_position>1</hierarchy_position>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                    <appearance><![CDATA[Flat]]></appearance>
                    <state>Capture</state>
                    <layout>None</layout>
                    <virtual_signals_definitions>
                        <virtual_signal_definition>
                            <name><![CDATA[Pout]]></name>
                            <type><![CDATA[Analog signal]]></type>
                            <source_signals>
                                <source_signal>
                                    <signal_name><![CDATA[Vout]]></signal_name>
                                    <argument_name><![CDATA[in1]]></argument_name>
                                </source_signal>
                                <source_signal>
                                    <signal_name><![CDATA[Iout]]></signal_name>
                                    <argument_name><![CDATA[in2]]></argument_name>
                                </source_signal>
                                </source_signals>
                            <code><![CDATA[
# Use this function to define the values of the newly created signal.

# The signals which you have specified in the input signals table
# will be passed to this function as arguments.

# Make sure to return a collection (Python list or Numpy ndarray) of
# numeric values. If you generate a collection which contains more
# elements than the original signals, the extra values will be sliced off.
# If you generate less values, zeroes will be appended to the collection.

# Numpy (np), Scipy (sp), Pandas (pd) and the math (math) module
# are pre-imported and ready to be used.
# 'time_data' ndarray variable holds x axis data used for all
# captured signals.

# return collection (list or ndarray) of numeric values
# e.g return in1 * in2, return in1 * 2
return in1 * in2
]]></code>
                        </virtual_signal_definition>
                    </virtual_signals_definitions>
                    <presets>
                        <active_capture_preset><![CDATA[Default]]></active_capture_preset>
                        <active_scope_preset><![CDATA[Default]]></active_scope_preset>
                        <capture name="Default">
                            <time_interval>10.0</time_interval>
                            <sample_rate>200000.0</sample_rate>
                            <background_color>white</background_color>
                            <layout>Vertical</layout>
                            <legend>True</legend>
                            <analog_signals>
                                <analog>
                                    <channel>0</channel>
                                    <name><![CDATA[Vout]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>0</row>
                                    <viewports>
                                        <num_viewport>1</num_viewport>
                                   </viewports>
                               </analog>
                                <analog>
                                    <channel>1</channel>
                                    <name><![CDATA[L]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>1</row>
                                    <viewports>
                                   </viewports>
                               </analog>
                                <analog>
                                    <channel>2</channel>
                                    <name><![CDATA[Iout]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>2</row>
                                    <viewports>
                                   </viewports>
                               </analog>
                                <analog>
                                    <channel>3</channel>
                                    <name><![CDATA[Controller.Imax]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>4</row>
                                    <viewports>
                                   </viewports>
                               </analog>
                            </analog_signals>
                            <digital_signals>
                            </digital_signals>
                            <virtual_signals>
                                <virtual>
                                    <name><![CDATA[Pout]]></name>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0</vertical_offset>
                                    <row>3</row>
                                    <viewports>
                                    </viewports>
                                </virtual>
                            </virtual_signals>
                            <trigger>
                                <device>0</device>
                                <is_force>True</is_force>
                                <type>Analog</type>
                                <source><![CDATA[Vout]]></source>
                                <edge>Rising edge</edge>
                                <treshold>0.0</treshold>
                                <offset>0.0</offset>
                                <useFirstTrigger>False</useFirstTrigger>
                            </trigger>
                            <plotting_options in_use="False">
                                <subplots>
                                    </subplots>
                            </plotting_options>
                        </capture>
                        <scope name="Default">
                            <background_color>white</background_color>
                            <layout>Vertical</layout>
                            <legend>True</legend>
                            <show_viewports>3</show_viewports>
                            <decimation>1.0</decimation>
                            <time_base>1e-05</time_base>
                            <analog_signals>
                                <analog>
                                    <channel>0</channel>
                                    <name><![CDATA[Vout]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>0</row>
                                    <viewports>
                                        <num_viewport>1</num_viewport>
                                   </viewports>
                               </analog>
                                <analog>
                                    <channel>1</channel>
                                    <name><![CDATA[L]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>1</row>
                                    <viewports>
                                        <num_viewport>2</num_viewport>
                                   </viewports>
                               </analog>
                                <analog>
                                    <channel>2</channel>
                                    <name><![CDATA[Iout]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>2</row>
                                    <viewports>
                                        <num_viewport>3</num_viewport>
                                   </viewports>
                               </analog>
                            </analog_signals>
                            <digital_signals>
                            </digital_signals>
                            <trigger>
                                <device>0</device>
                                <is_force>False</is_force>
                                <type>Analog</type>
                                <source>Vout</source>
                                <edge>Rising edge</edge>
                                <treshold>0.0</treshold>
                                <offset>0.0</offset>
                                <useFirstTrigger>False</useFirstTrigger>
                            </trigger>
                        </scope>
                        </presets>
                    <capture>
                        <time_interval>10.0</time_interval>
                        <sample_rate>200000.0</sample_rate>
                        <background_color>white</background_color>
                        <layout>Vertical</layout>
                        <legend>True</legend>
                        <trigger>
                            <type>Analog</type>
                            <source>Vout</source>
                            <edge>Rising edge</edge>
                            <treshold>0.0</treshold>
                            <offset>0.0</offset>
                            <useFirstTrigger>False</useFirstTrigger>
                        </trigger>
                        <analog_signals>
                            <analog>
                                    <channel>0</channel>
                                    <name><![CDATA[Vout]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>0</row>
                                    <viewports>
                                        <num_viewport>1</num_viewport>
                                   </viewports>
                               </analog>
                            <analog>
                                    <channel>1</channel>
                                    <name><![CDATA[L]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>1</row>
                                    <viewports>
                                   </viewports>
                               </analog>
                            <analog>
                                    <channel>2</channel>
                                    <name><![CDATA[Iout]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>2</row>
                                    <viewports>
                                   </viewports>
                               </analog>
                            <analog>
                                    <channel>3</channel>
                                    <name><![CDATA[Controller.Imax]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>4</row>
                                    <viewports>
                                   </viewports>
                               </analog>
                        </analog_signals>
                         <digital_signals>
                         </digital_signals>
                    </capture>
                    <scope>
                        <time_base>1e-05 </time_base>
                        <background_color>white</background_color>
                        <layout>Vertical</layout>
                        <legend>True</legend>
                        <trigger>
                            <mode>Auto</mode>
                            <type>Analog</type>
                            <source>Vout</source>
                            <edge>Rising edge</edge>
                            <treshold>0.0</treshold>
                            <offset>0.0</offset>
                        </trigger>
                         <analog_signals>
                            <analog>
                                    <channel>0</channel>
                                    <name><![CDATA[Vout]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>0</row>
                                    <viewports>
                                        <num_viewport>1</num_viewport>
                                   </viewports>
                               </analog>
                            <analog>
                                    <channel>1</channel>
                                    <name><![CDATA[L]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>1</row>
                                    <viewports>
                                        <num_viewport>2</num_viewport>
                                   </viewports>
                               </analog>
                            <analog>
                                    <channel>2</channel>
                                    <name><![CDATA[Iout]]></name>
                                    <is_locked>False</is_locked>
                                    <vertical_scale>Auto</vertical_scale>
                                    <vertical_offset>0.0</vertical_offset>
                                    <coupling>False</coupling>
                                    <row>2</row>
                                    <viewports>
                                        <num_viewport>3</num_viewport>
                                   </viewports>
                               </analog>
                        </analog_signals>
                        <digital_signals>
                        </digital_signals>
                    </scope>
                    <plotting_options in_use="False">
                    
                        <subplots>
                            </subplots>
                    </plotting_options>
                </widget_settings>

            </component_data>
        <component_data>
                <id>baf207ad32c411ef8f2bdbfccc9e91fd</id>
                <name><![CDATA[Load resistance]]></name>
                <type>SliderMacro</type>
                <description><![CDATA[]]></description>
                <on_use_code active="True"><![CDATA[# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.
# NOTE: entered value is available through variable 'inputValue'

hil.model_write('Load resistance', inputValue)

Vout = panel.get_property_value(panel.get_widget_by_fqn('Control panel.Reference output voltage'), api_const.PROP_WIDGET_VALUE)

compensation_gain = get_compensating_gain(inputValue, Vout, Vin, RL, L, Cout)
hil.model_write('Controller.Gain.gain', compensation_gain)]]></on_use_code>
                <on_start_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed on simulation start.
# NOTE: Variables specified here will be available in other handlers.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_start_code>
                <on_stop_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed after simulation is stopped.
# HIL API is imported as 'hil'
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change widget value by setting this variable.
# NOTE: If you not specify 'widgetValue' variable or assign 'None' to it,
# widget value won't be changed.
widgetValue = None
]]></on_stop_code>
                <on_timer_code active="False"><![CDATA[# NOTE: The code specified in this handler will be executed periodically each 1000ms.
# HIL API is imported as 'hil'
# NOTE: Only read functions are available from the HIL API
# SCADA API is imported as 'panel'
# SCADA API constants are imported as 'api_const'
# 'WIDGET_HANDLE' constant holds the WidgetHandle object of this widget.
# This object can be used as an argument in SCADA API functions.

# Change the widget value by setting this variable.
# NOTE: If you do not specify a 'widgetValue' variable or assign 'None' to it,
# the widget value will not be changed.
widgetValue = None
]]></on_timer_code>
                <on_start_code_source><![CDATA[Custom code]]></on_start_code_source>
                <inputValue><![CDATA[8.0]]></inputValue>
                <min>5.0</min>
                <max>20.0</max>
                <step>1.0</step>
                <widget_settings>
                    <x>584</x>
                    <y>280</y>
                    <width>328</width>
                    <height>48</height>
                    <appearance><![CDATA[Flat]]></appearance>
                    <hierarchy_position><![CDATA[2]]></hierarchy_position>
                    <is_background><![CDATA[False]]></is_background>
                    <label><![CDATA[]]></label>
                    <use_label>False</use_label>
                </widget_settings>
            </component_data>
        </components>
</ui_settings>